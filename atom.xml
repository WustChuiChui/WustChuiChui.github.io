<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐家凌的blog</title>
  <subtitle>徐家凌</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://WustChuiChui.github.io/"/>
  <updated>2016-04-25T12:42:39.677Z</updated>
  <id>http://WustChuiChui.github.io/</id>
  
  <author>
    <name>Wust_锤锤</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python package</title>
    <link href="http://WustChuiChui.github.io/2016/04/25/Python-package/"/>
    <id>http://WustChuiChui.github.io/2016/04/25/Python-package/</id>
    <published>2016-04-25T12:42:39.000Z</published>
    <updated>2016-04-25T12:42:39.677Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python学习笔记 类的继承</title>
    <link href="http://WustChuiChui.github.io/2016/04/25/Python-inherit/"/>
    <id>http://WustChuiChui.github.io/2016/04/25/Python-inherit/</id>
    <published>2016-04-25T11:20:44.000Z</published>
    <updated>2016-04-25T12:02:35.987Z</updated>
    
    <content type="html">&lt;p&gt;让代码更有条理，这只是使用对象的好处之一。另一个更有用的好处是继承。可以通过指向一个已有的对象来定义对象，然后对他添加更多的属性和方法，从而定义一个新的对象。通过继承，可以不必重新编写代码来做同样的事情，只需要针对一些略微不同的项重新编写代码即可。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、类的定义方法&quot;&gt;&lt;a href=&quot;#一、类的定义方法&quot; class=&quot;headerlink&quot; title=&quot;一、类的定义方法&quot;&gt;&lt;/a&gt;一、类的定义方法&lt;/h2&gt;&lt;p&gt;这里通过一个实例来说明Python中类的定义方法。首先我们定义一个库存项类，它具有标题，说明和价格等基本属性，包含对应的方法。有一个书籍类从库存项类继承，并新定义了作者和格式两个属性，添加了几个新的方法，并重新定义一些函数等。&lt;/p&gt;
&lt;p&gt;首先，先看看InventoryItem的基本的项。其他对象都是派生自这个对象。InventoryItem有title,description,price,ID属性，如果打印它，返回该项的名称。如果想查看两个项是否相等，它比较库存ID，除此之外，还有三个函数，分别用来修改价格，说明和名称。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class InventoryItem(object):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;&amp;quot;&amp;quot;定义一个库存项基类，包含title,description,price三个属性，含有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       change_description,change_price,change_title三个方法    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __init__(self,title,description,price,store_id):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.title=title             #标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.description=description  #说明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.price=price              #价格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.store_id=store_id         #库存编号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #用来返回输出值的函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __str__(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return self.title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #用来判断对象是否相等的函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __eq__(self,other):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if self.store_id==other.store_id:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return False&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #change_description方法，用来修正对象的说明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def change_description(self,description=&amp;quot;&amp;quot;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if not description:   #没有输入描述参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            description=raw_input(&amp;quot;Please give me a description:&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.description=description&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #change_price方法，用来修正对象的价格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def change_price(self,price=-1):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while price&amp;lt;0:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            price=raw_input(&amp;quot;Please input the new price:&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            try:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                price=float(price)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            except:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                print &amp;quot;I&amp;apos;m sorry, but &amp;#123;&amp;#125; isn&amp;apos;t valid.&amp;quot;.format(price)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.price=price&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #change_title方法，用来修正对象的标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def change_title(self,title=&amp;quot;&amp;quot;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if not title:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            title=raw_input(&amp;quot;Please give me the a new title:&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.title=title&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在有一个基类，我们接下来创建一个继承于它的新类Book。把类的名称放在通常放置对象的圆括号中，从而告诉Python，想要继承自该类。所以函数声明需要用“class Book(InventoryItem):”,而不是“class Book(object):”。&lt;br&gt;这里的Book类新定义了两个属性:format和author,打印该对象时，返回标题和作者（基类中返回标题），判断两个Book类的对象是否相等时，同时比较标题和作者，若二者均相等时，则返回True,除此之外，还有两个方法，用来改变format和author属性。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Book(InventoryItem):   #将基类名称作为放置对象，表示继承&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;&amp;quot;&amp;quot;定义一个Book类，该类继承于InventoryItem类，并添加了author和format两个属性，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       添加了change_author,change_format方法，并重新定义了一个print方法用来输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __init__(self,title,description,price,format,author,store_id):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(Book,self).__init__(title=title,description=description,price=price,store_id=store_id)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.format=format&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.format=author&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __str__(self): #打印时返回标题和作者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        book_line=&amp;quot;&amp;#123;title&amp;#125; by &amp;#123;author&amp;#125;&amp;quot;.format(title=self.title,author=self.author)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return book_line&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __eq__(self,other): #判断两个Book类的对象是否相等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if self.title==other.title and self.author==other.author:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return False&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def change_format(self,format):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if not format:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            format=raw_input(&amp;quot;Please input the new format:&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.format=format&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def change_author(self,author):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if not author:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            author=raw_input(&amp;quot;Please input the author:&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.author=author&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里子类中的&lt;strong&gt;init&lt;/strong&gt;()方法中，有一个super()方法，它是Python中一个特殊的函数，它告诉Python调用父类中的一个函数。通过这个方法，我们不需要重复写同样的代码。同时，子类中的&lt;strong&gt;eq&lt;/strong&gt;()和&lt;strong&gt;str&lt;/strong&gt;()方法覆盖了基类中对应的方法。&lt;/p&gt;
&lt;p&gt;下面我们对上述类做个简单的测试：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hamlet=Book(title=&amp;quot;Hamlet&amp;quot;,description=&amp;quot;A Dane has a bad time.&amp;quot;,price=5.99,format=&amp;quot;paperback&amp;quot;,store_id=&amp;quot;29382918&amp;quot;,author=&amp;quot;William Shakespears&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hamlet_hardback=Book(title=&amp;quot;Hamlet&amp;quot;,description=&amp;quot;A Dane has a bad time.&amp;quot;,price=5.99,format=&amp;quot;paperback&amp;quot;,store_id=&amp;quot;29382918&amp;quot;,author=&amp;quot;William Shakespears&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;macbeth=Book(title=&amp;quot;Macbeth&amp;quot;,description=&amp;quot;Don&amp;apos;t listen to strange ladies on the side of the road.&amp;quot;,price=4.99,format=&amp;quot;paperback&amp;quot;,store_id=&amp;quot;23928932&amp;quot;,author=&amp;quot;William Shakespears&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hamlet==hamlet_hardback&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hamlet==macbeth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(hamlet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hamlet.change_description(&amp;quot;The trouble with remarriage.&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;macbeth.change_format(format=&amp;quot;audiobook&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;macbeth.format&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hamlet.description&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其输出结果为：&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006qSkuxgw1f3978wyaqrj30de07z3zz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;让代码更有条理，这只是使用对象的好处之一。另一个更有用的好处是继承。可以通过指向一个已有的对象来定义对象，然后对他添加更多的属性和方法，从而定义一个新的对象。通过继承，可以不必重新编写代码来做同样的事情，只需要针对一些略微不同的项重新编写代码即可。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协同过滤推荐算法简介</title>
    <link href="http://WustChuiChui.github.io/2016/04/19/Collaborative-Filtering/"/>
    <id>http://WustChuiChui.github.io/2016/04/19/Collaborative-Filtering/</id>
    <published>2016-04-19T12:13:04.000Z</published>
    <updated>2016-04-19T14:33:13.192Z</updated>
    
    <content type="html">&lt;p&gt;协同过滤通过用户和产品及用户的偏好信息产生推荐的策略，最基本的策略有两种：一种是找到具有类似品味的人所喜欢的物品；另一种是从一个人喜欢的物品中找出类似的物品。这对应着两个最知名的类别推荐技术：基于用户的推荐技术和基于物品的推荐技术，它们被称为协同过滤。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h2&gt;&lt;p&gt;协同过滤推荐（Collaborative Filtering Recommendation）是在信息过滤和信息系统中正迅速成为一项很受欢迎的技术。与传统的基于内容过滤直接分析内容进行推荐不同，协同过滤分析用户兴趣，在用户群中找到指定用户的相似（兴趣）用户，综合这些相似用户对某一信息的评价，形成系统对该指定用户对此信息的喜好程度预测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 优点： &lt;/strong&gt;&lt;br&gt;1）能够过滤难以进行机器自动基于内容分析的信息；&lt;br&gt;2）能够基于一些复杂的，难以表达的概念（信息质量，品味）进行过滤；&lt;br&gt;3）推荐的新颖性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 缺点： &lt;/strong&gt;&lt;br&gt;1）用户对商品的评价非常稀疏，这样基于用户的评价所得到的用户间的相似性可能不准确（稀疏性问题）；&lt;br&gt;2）随着用户和商品的增多，系统的性能会越来越低；&lt;br&gt;3）如果从来没有用户对某一商品加以评价，则这个商品就不可能被推荐（冷启动问题）。&lt;/p&gt;
&lt;h2 id=&quot;基本模型&quot;&gt;&lt;a href=&quot;#基本模型&quot; class=&quot;headerlink&quot; title=&quot;基本模型&quot;&gt;&lt;/a&gt;基本模型&lt;/h2&gt;&lt;p&gt;1）数据预处理与UI矩阵&lt;br&gt;2）推荐模型：item-based CF和user-based CF&lt;br&gt;item-based CF:基于item的协同过滤，通过用户对不同item的评分来评测item之间的相似性，基于item之间的相似性做出推荐；&lt;br&gt;user-based CF:基于user的协同过滤，通过不同用户对item的评分来评测之间的相似性，基于用户之间的相似性做出推荐。&lt;br&gt;3）Kmeans计算相似性&lt;br&gt;4）SVD计算相似性&lt;br&gt;&lt;strong&gt; 数据预处理 &lt;/strong&gt;&lt;br&gt;多数情况下，大型电子商务网站都提供多种跟踪用户行为的方法，关于如何组合这些不同的用户行为，基本上可以参考以下两种方式：&lt;br&gt;1）将不同的行为分组：一般可以分为“查看”和“购买”等，然后基于不同的行为计算不同的用户/物品相似度。&lt;br&gt;2）根据不同行为反应用户的偏好的程度将它们进行加权，得到用户对于物品的总体偏好。一般来说，显示的用户反馈要比隐式的权值大，但比较稀疏，毕竟进行显示反馈的用户是少数。&lt;br&gt;3）收集了用户行为数据，我们还要对数据进行一定的预处理，降噪和归一化是最常用的方法，其目的是为了下一步的聚类。&lt;br&gt;降噪：用户行为数据是用户在使用应用过程中产生的，它可能存在大量的噪声和用户的误操作，我们可以通过一些降噪算法过滤掉数据中的噪声，一般是离群点，这样可以使分析更精确；&lt;br&gt;归一化：在计算用户对物品的偏好程度时，不同行为的数据取值量纲不同，甚至可能相差很大。归一化的目标就是统一量纲，使数据都集中在一个相同的取值范围中，从而使用户的总体偏好更加精确；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 推荐模型 &lt;/strong&gt;&lt;br&gt;user-based CF:基于用户的CF的基本思想相当简单：基于用户对物品的偏好划分用户类型(聚类)，找到最近邻用户（KNN近邻算法），然后将同类用户和相邻用户所喜欢的推荐给当前用户。计算上，就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到K邻居后，根据邻居的相似度权重及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐。&lt;br&gt;item-based CF:基于物品的CF的基本思想和基于用户的CF类似，只是在计算时采用物品之间的相似度，而不是从用户的角度，即基于用户对物品的偏好划分物品类型找到最近邻物品，然后将同类物品或相邻物品推荐给当前用户。从计算的角度看，就是将所有的用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;协同过滤通过用户和产品及用户的偏好信息产生推荐的策略，最基本的策略有两种：一种是找到具有类似品味的人所喜欢的物品；另一种是从一个人喜欢的物品中找出类似的物品。这对应着两个最知名的类别推荐技术：基于用户的推荐技术和基于物品的推荐技术，它们被称为协同过滤。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法基础练习   最小的k个数+扩展大数据</title>
    <link href="http://WustChuiChui.github.io/2016/04/18/kLeastnumbers/"/>
    <id>http://WustChuiChui.github.io/2016/04/18/kLeastnumbers/</id>
    <published>2016-04-18T08:50:42.000Z</published>
    <updated>2016-04-19T08:00:41.427Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt; 题目描述： &lt;/strong&gt;&lt;br&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;问题分析：&quot;&gt;&lt;a href=&quot;#问题分析：&quot; class=&quot;headerlink&quot; title=&quot;问题分析：&quot;&gt;&lt;/a&gt;问题分析：&lt;/h3&gt;&lt;p&gt;最简单的思路应该是对数据进行排序，排序后得到的前k个数字就是要求的数据。这种思路的时间复杂度为O(nlogn)。&lt;br&gt;如果能修改数组中的数字，可以参考快速排序中的方法，选取第k个数作为参考，将比它小的数字全部放在左侧，比它大的数字全放在右侧。那么左侧的k个数字就是最终的结果数字。这种思路的时间复杂度为O(n)。代码实现如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void GetLeastNumbers(int* input,int n,int* output,int k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(input==NULL || output==NULL || k&amp;gt;n || n&amp;lt;=0 || k&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int start=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int end=n-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int index=Partition(input,n,start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(index!=k-1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(index&amp;gt;k-1)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            end=index-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            index=Partition(input,n,start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int Partition(int* data,int length,int start,int end)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(data==NULL || length&amp;lt;=0 || start&amp;lt;0 || end&amp;gt;=length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throw new std::exception(&amp;quot;Invalid Parameters&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int index=RandomInRange(start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Swap(&amp;amp;data[index],&amp;amp;data[end]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int small=start-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(index=start;index&amp;lt;end;++index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(data[index]&amp;lt;data[end])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ++small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(small!=index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Swap(&amp;amp;data[index],&amp;amp;data[small]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ++small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Swap(&amp;amp;data[small],&amp;amp;data[end]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这种思路是有一定限制条件的。我们需要修改输入的数组，因为函数Partition会调整数组中的数字的顺序。&lt;/p&gt;
&lt;h3 id=&quot;思路二：&quot;&gt;&lt;a href=&quot;#思路二：&quot; class=&quot;headerlink&quot; title=&quot;思路二：&quot;&gt;&lt;/a&gt;思路二：&lt;/h3&gt;&lt;p&gt;我们可以先创建一个大小为k的数据容器来储存最小的k个数字，接下来我们每次从输入的n个整数中读入一个数。1）如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；2）如果容器中已有k个数字，也就是容器已满，此时我们不能直接插入数字。我们找出容器中k个数字的最大值，然后和这次待插入的整数进行比较。3）如果待插入的值比已有的最大值小，则用这次插入的数据替换当前已有的最大值；4）如果待插入的值比已有的最大值大，则直接丢弃。最后容器中的k个数即为最终要求的结果。&lt;br&gt;因此当容器满了之后，我们要做三件事：一是在k个整数中找到最大数；二是有可能删除容器中的最大数；三是有可能要插入一个新的数据。用二叉树的结构来考虑，实现找出n个数据中最小的k个，时间复杂度为O(nlogk)。&lt;br&gt;&lt;strong&gt; 红黑树 &lt;/strong&gt;是一种自平衡的二叉树结构，红黑树通过把节点分为红黑两种颜色并根据一些规则确保树在一定程度上是平衡的，从而保证在红黑树中查找、删除和插入操作都只需要O(logk)时间。STL中set和multiset都是基于红黑树实现的。利用set和multiset可以实现题目要求&lt;br&gt;的查找。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef multiset&amp;lt;int,greater&amp;lt;int&amp;gt;&amp;gt;            intSet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef multiset&amp;lt;int,greater&amp;lt;int&amp;gt;&amp;gt;::interator setIterator;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void GetLeastNumbers(const vector&amp;lt;int&amp;gt;&amp;amp; data,intSet&amp;amp; leastNumbers,int k)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    leastNumbers.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(k&amp;lt;1 || data.size()&amp;lt;k)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;int&amp;gt;::const_iterator iter=data.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(;iter!=data.end();++iter)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(leastNumbers.size()&amp;lt;k)       //容器未满&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            leastNumbers.insert(*iter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            setIterator iterGreatest=leastNumbers.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(*iter&amp;lt;*(leastNumbers.begin()))&amp;#123;      //待插入的数较小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                leastNumbers.erase(iterGreatest);   //删除容器中最大的一个值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                leastNumbers.insert(*iter);  //将待插入的数加到容器中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;对比分析&quot;&gt;&lt;a href=&quot;#对比分析&quot; class=&quot;headerlink&quot; title=&quot;对比分析&quot;&gt;&lt;/a&gt;对比分析&lt;/h3&gt;&lt;p&gt;基于函数Partition的方法时间复杂度O(n),比后者思路要快，但同时也有限制，比如会修改数组中的数据。&lt;br&gt;后者的解法思路虽稍慢一点，但有两个优点。一是没有修改输入的数据。二是它比较适合海量的数据的输入。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 题目描述： &lt;/strong&gt;&lt;br&gt;输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法编程练习 数组中出现次数超过一半的数字</title>
    <link href="http://WustChuiChui.github.io/2016/04/18/more-than-half-0/"/>
    <id>http://WustChuiChui.github.io/2016/04/18/more-than-half-0/</id>
    <published>2016-04-18T08:13:02.000Z</published>
    <updated>2016-04-18T08:14:01.132Z</updated>
    
    <content type="html">&lt;p&gt;题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;题目分析：&quot;&gt;&lt;a href=&quot;#题目分析：&quot; class=&quot;headerlink&quot; title=&quot;题目分析：&quot;&gt;&lt;/a&gt;题目分析：&lt;/h3&gt;&lt;p&gt;如果是排好序的数组，那么只需一遍遍历即可找出是否存在一个数字出现次数超过数组长度的一半。因此如果先对数组进行快速排序，再一次遍历可以得到结果，此时时间复杂度为O(nlogn)。&lt;br&gt;此时的时间复杂度相对较高，考虑换一种思路解决该问题。数组中有一个数字出现的次数超过了数组长度的一半，如果将这个数组排序，那么排序之后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字，也就是统计学中的中位数。&lt;br&gt;我们可以考虑先随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的全部在它的左边，比选中的数字大的全部在右边。如果这个选中的数字的下标刚好是n/2，那么这个数就是数组的中位数。如果这个选中的数字的下标大于n/2，那么中位数应该在它的左侧，应该在它的左侧查找。如果这个选中的数字的下标小于n/2，那么中位数应该在它的右侧，应该在它的右侧查找。可以用下述代码实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int MoreThanHalfNum(vector&amp;lt;int&amp;gt; numbers)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(numbers.empty())    //向量容器为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int length=numbers.size();  //输入数据非法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(CheckInvalidArray(numbers,length))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int middle=length&amp;gt;&amp;gt;1;    //位移运算代替除2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int start=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int end=length-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int Partition(numbers,length,start,end);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(index!=middle)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(index&amp;gt;middle)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            end=index-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            index=Partition(numbers,length,start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            start=index+1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            index=Partition(numbers,length,start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int result=numbers[middle];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(!CheckMoreThanHalf(numbers,length,result))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool g_bInputInvalid=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool CheckInvalidArray(vector&amp;lt;int&amp;gt; numbers,int length)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    g_bInputInvalid=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(numbers.empty() || length&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        g_bInputInvalid=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return g_bInputInvalid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool CheckMoreThanHalf(vector&amp;lt;int&amp;gt; numbers,int length,int number)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int times=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(int i=0;i&amp;lt; length;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(numbers[i]==number)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            times++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool isMoreThanHalf=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(times*2&amp;lt;=length)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        g_bInputInvalid=true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isMoreThanHalf=false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return isMoreThanHalf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int Partition(vector&amp;lt;int&amp;gt; data,int length,int start,int end)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(data.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(data.size()!=length || length&amp;lt;=0 || start&amp;lt;0 || end&amp;gt;=length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throw new std::exception(&amp;quot;Invalid Parameters&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int index=RandomInRange(start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Swap(&amp;amp;data[index],&amp;amp;data[end]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int small=start-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(index=start;index&amp;lt;end;++index)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(data[index]&amp;lt;data[end])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ++small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(small!=index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Swap(&amp;amp;data[index],&amp;amp;data[small]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ++small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Swap(&amp;amp;data[small],&amp;amp;data[end]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;除了上述思路之外，数组中一个数组出现的次数超过数组的长度的一半，那么它出现的次数比其他数字出现次数的累加和还要多。我们如果在遍历时储存两个值，一个是数组中的值，一个为出现的次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，我们将次数加1，如果出现的数字不同，则将次数减1，次数为零的时候需要保存下一个数字，次数设为1.如果最终我们储存的数字出现的次数超过数组长度的一半，那么肯定是最后一次把次数设为1的数字。参考代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int MoreThanHalfNum_Solution(vector&amp;lt;int&amp;gt; numbers) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         int length=numbers.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         if(CheckInvalidArray(numbers,length))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int result=numbers[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int times=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i=1;i&amp;lt;length;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(times==0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result=numbers[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                times=1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else if(numbers[i]==result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                times++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                times--;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(!CheckMoreThanHalf(numbers,length,result))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result=0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python基础    Python中的基本数据类型</title>
    <link href="http://WustChuiChui.github.io/2016/04/17/python-data-type/"/>
    <id>http://WustChuiChui.github.io/2016/04/17/python-data-type/</id>
    <published>2016-04-17T13:55:21.000Z</published>
    <updated>2016-04-18T02:41:03.720Z</updated>
    
    <content type="html">&lt;p&gt;除了常规的字符串和数值类型之外，Python还提供了另外4种重要的基本数据类型：元组、列表、集合和字典。这4中类型有许多共同点，因为它们都允许在一个名称下面组织多条数据。因为具有这种组织性，每个类型都允许在它们中查找元素。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;元组——不可更改的数据序列&quot;&gt;&lt;a href=&quot;#元组——不可更改的数据序列&quot; class=&quot;headerlink&quot; title=&quot;元组——不可更改的数据序列&quot;&gt;&lt;/a&gt;元组——不可更改的数据序列&lt;/h2&gt;&lt;p&gt;元组是Python中定义的一种基本数据类型。在创建的时候就可以识别出元组，因为它们被圆括号包围：&lt;br&gt;元组包含对数据的引用，例如对字符串和数值的引用，元组中的数据不可更改。然而，虽然它们引用数据，但是仍然是可以像其他类型的数据一样为它们命名：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;filler=(&amp;quot;string&amp;quot;,&amp;quot;filled&amp;quot;,&amp;quot;by a&amp;quot;,&amp;quot;tuple&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;A %s %s %s %s&amp;quot; % (&amp;quot;string&amp;quot;,&amp;quot;filled&amp;quot;,&amp;quot;by a&amp;quot;,&amp;quot;tuple&amp;quot;)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A string filled by a tuple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果直接用print()函数调用元组，打印其结果，则：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;filler=(&amp;quot;string&amp;quot;,&amp;quot;filled&amp;quot;,&amp;quot;by a&amp;quot;,&amp;quot;tuple&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(filler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&amp;apos;string&amp;apos;,&amp;apos;filled&amp;apos;,&amp;apos;by a&amp;apos;,&amp;apos;tuple&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;filler元组的处理方式好像是它的元素都呈现处理并且被字符串用来填充格式说明符，因为元组的处理方式就好像输入一个序列来满足给定的格式规范。也可以访问元组中的单个值。每个元素引用的值可以通过该语言的解除引用特征性直接访问。通过在元组的名称后放置方括号并且从0起计算要引用的元素的位置，可以解除元组中对值的引用。如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=(&amp;quot;first&amp;quot;,&amp;quot;second&amp;quot;,&amp;quot;third&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;The first element of the tuple is %s&amp;quot; % a[0])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The first element of the tuple is first&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;%d&amp;quot; % len(a))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a[len(a)-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;third&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;并且，可以通过一个元组访问另外一个元组，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=(&amp;quot;first&amp;quot;,&amp;quot;second&amp;quot;,&amp;quot;third&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b=(a,&amp;quot;b&amp;apos;s second element&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;%s&amp;quot; b[1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b&amp;apos;s second element&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;%s&amp;quot; % b[0][0])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;first&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 值得注意的是，元组可以各种类型的数据，但在创建之后，就不能再改变。 &lt;/strong&gt; 元组之所以不可变，是因为Python中使用元组存储一组有序的事物，这些事物在使用时是不可以更改的。如果尝试修改元组中的元素将导致Python报错。&lt;/p&gt;
&lt;h2 id=&quot;列表——可以更改的数据序列&quot;&gt;&lt;a href=&quot;#列表——可以更改的数据序列&quot; class=&quot;headerlink&quot; title=&quot;列表——可以更改的数据序列&quot;&gt;&lt;/a&gt;列表——可以更改的数据序列&lt;/h2&gt;&lt;p&gt;列表和元组很像，是包含从0开始引用的元素的序列。列表用方括号创建：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;breakfast=[&amp;quot;coffee&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;toast&amp;quot;,&amp;quot;egg&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;列表中的单个元素的访问方法与元组类似。像元组一样，列表中的元素从0开始引用，并且访问顺序也是从0开始知道末端。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;count=0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;Today&amp;apos;s breakfast is %s &amp;quot; % breakfast[count])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Today&amp;apos;s breakfast is coffee&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当顺序访问列表中的多个元素时，有必要使用一个名称来存储目前在列表中所处的位置。使用列表与使用元组主要的区别在于，&lt;strong&gt; 元组在创建后不可以修改，列表在任何时刻都可以被修改： &lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;breakfast[count]=&amp;quot;sausages&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;Today&amp;apos;s breakfast is %s &amp;quot; % breakfast[count]&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Today&amp;apos;s breakfast is sausages&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;除了直接修改列表中已经存在的元素，还可以向列表中添加需要的元素。可以用列表类型的内置方法append向列表末端添加元素。利用append方法每次只能添加一个元素。如果希望一次性地向列表末端添加多个元素，如一个列表或元组中的内容，可以使用extend方法。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;breakfast.extend([&amp;quot;juice&amp;quot;,&amp;quot;decaf&amp;quot;,&amp;quot;oatmeal&amp;quot;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(breakfast)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;apos;sausages&amp;apos;,&amp;apos;tea&amp;apos;,&amp;apos;toast&amp;apos;,&amp;apos;egg&amp;apos;,&amp;apos;waffle&amp;apos;,&amp;apos;juice&amp;apos;,&amp;apos;decaf&amp;apos;,&amp;apos;oatmeal&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;列表的长度也是通过len函数确定。就像元组一样，长度从1开始，而列表的第一个元素的位置从0开始。&lt;/p&gt;
&lt;h2 id=&quot;字典——以名称索引的分组数据&quot;&gt;&lt;a href=&quot;#字典——以名称索引的分组数据&quot; class=&quot;headerlink&quot; title=&quot;字典——以名称索引的分组数据&quot;&gt;&lt;/a&gt;字典——以名称索引的分组数据&lt;/h2&gt;&lt;p&gt;字典类似于列表和元组。它是包含一组数据的另外一种容器。然而，元组和列表以数字顺序索引，字典却用选择的名称索引。这些名称可以是字母、数值、字符串或者符号。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;menus_specials=&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;menus_specials[&amp;quot;breakfast&amp;quot;]=&amp;quot;Canadian ham&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;menus_specials[&amp;quot;lunch&amp;quot;]=&amp;quot;Tuna surprise&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;menus_specials[&amp;quot;dinner&amp;quot;]=&amp;quot;Cheeseburger Deluxe&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述代码可以创建一个字典，字典一旦被定义并且通过名称引用，将开始使用如下方式对其实例化：将希望作为索引的名称放在方括号内，将通过该索引引用的值放在等号的右端。其中，索引和值都有特殊的名称。&lt;strong&gt; 字典中索引的名称叫做键，对应的值叫做值。 &lt;/strong&gt;为了创建一个完全指定（或者可以认为它是完全形成的）字典，必须在花括号之间指定每个键以及和它对应的值，并以冒号分隔它们，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;menus_specials=&amp;#123;&amp;quot;breakfast&amp;quot;:&amp;quot;sausage and eggs&amp;quot;,&amp;quot;lunch&amp;quot;:&amp;quot;split pea soup and garlic bread&amp;quot;,&amp;quot;dinner&amp;quot;:&amp;quot;2 hot dogs and onion rings&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;要打印出某个字典中所有的键与值，只需将该字典的名称作为print()函数的参数，同样地，可以将键放在方括号中。如果键是字符串，需要将键在引号中。如果键是数值，则使用数值引用即可。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(munus_specials)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;apos;breakfast&amp;apos;:&amp;apos;sausage and eggs&amp;apos;,&amp;apos;lunch&amp;apos;:&amp;apos;split pea soup and garlic bread&amp;apos;,&amp;apos;dinner&amp;apos;:&amp;apos;2 hot dogs and onion rings&amp;apos;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;%s &amp;quot; % menu_specials[&amp;quot;breakfast&amp;quot;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sausage and eggs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&amp;quot;%s &amp;quot; % menu_specials[&amp;quot;dinner&amp;quot;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 hot dogs and onion rings&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果键是一个字符串，但是在方括号中意外地没有将键放在引号中，Python就试图将它看做一个名称，需要解除对它的引用来找到键。一般情况下，会引起一个NameError异常，除非凑巧找到了一个与该字符串相同的名称，这时会得到一个IndexError错误。&lt;br&gt;可以使用keys方法查看字典中的所有键，以便用户查找所需的键，同样地，可以使用values方法查看所有的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hungry=menus_specials.keys()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(list(hungry))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;breakfast&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lunch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dinner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;starving=menus_specials.value()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(list(starving))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sausage and eggs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;split pea soup and garlic bread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 hot dogs and onion rings&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Python中允许不同的键对应相同的值，但是，当重复定义相同的键时，虽然不会报错，但也存在下述错误：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;menus2=&amp;#123;&amp;quot;breakfast&amp;quot;:&amp;quot;spam&amp;quot;,&amp;quot;breakfast&amp;quot;:&amp;quot;ham&amp;quot;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;menus2.get(&amp;quot;breakfast&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;ham&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h2&gt;&lt;p&gt;在Python中，集合与字典类似，只是它包含键，而没有与键相关联的值。本质上，集合是不包括重复数据的数据集，从数据集删除重复数据时，集合非常实用。Python中有两种类型的集合：可变集合与不可变集合。两种的不同之处在于，对于可变集合，可以增加、删除或者改变它的元素，而不可变集合中的元素在它们被初始设定之后就不能再被更改。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alphabet=[&amp;apos;a&amp;apos;,&amp;apos;b&amp;apos;,&amp;apos;b&amp;apos;,&amp;apos;c&amp;apos;,&amp;apos;a&amp;apos;,&amp;apos;d&amp;apos;,&amp;apos;e&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(alphabet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;apos;a&amp;apos;,&amp;apos;b&amp;apos;,&amp;apos;b&amp;apos;,&amp;apos;c&amp;apos;,&amp;apos;a&amp;apos;,&amp;apos;d&amp;apos;,&amp;apos;e&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alph2=set(alphabet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;apos;a&amp;apos;,&amp;apos;c&amp;apos;,&amp;apos;b&amp;apos;,&amp;apos;e&amp;apos;,&amp;apos;d&amp;apos;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述例子中数据集alphabet作为输入，并将其转换为一个集合。因为集合不允许重复的值，多余的字符a和b被删除。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 元组 &lt;/strong&gt;是从0开始以固定数值顺序索引的一个数据序列。元组中的引用在元组被创建后不能被修改，也不能再添加或者删除元素。然而，如果元组包含可变元素的数据类型，该数据类型的元素是可以改变的。&lt;br&gt;&lt;strong&gt; 列表 &lt;/strong&gt;是另一种序列，处理它的元素可以被修改之外，它与元组类似。列表的长度可以改变，以容纳使用append方法新增加的元素，另外也可以通过pop方法缩减列表的长度。&lt;br&gt;&lt;strong&gt; 字典 &lt;/strong&gt;是另外一种有索引的数据分组。列表和元组以数值为索引，而字典通过所选的值索引。如果想研究这些索引（键），可以使用keys方法。为了研究被引用的数据（值），可以使用values方法。&lt;br&gt;&lt;strong&gt; 集合 &lt;/strong&gt;是项集，不允许包含重复的值。理论上，它们与字典类似，不过它们只包含键，而没有与键相关联的值。集合的一个用途是从数据集中取出冗余的值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;除了常规的字符串和数值类型之外，Python还提供了另外4种重要的基本数据类型：元组、列表、集合和字典。这4中类型有许多共同点，因为它们都允许在一个名称下面组织多条数据。因为具有这种组织性，每个类型都允许在它们中查找元素。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的重建</title>
    <link href="http://WustChuiChui.github.io/2016/04/17/binary-tree-reconstruct/"/>
    <id>http://WustChuiChui.github.io/2016/04/17/binary-tree-reconstruct/</id>
    <published>2016-04-17T12:50:40.000Z</published>
    <updated>2016-04-17T13:54:12.406Z</updated>
    
    <content type="html">&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序序列和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建该二叉树并返回它的头结点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;二叉树的节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct BinaryTreeNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int             m_nValue;   //data域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BinaryTreeNode* m_pleft;    //左孩子的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BinaryTreeNode* m_pright;   //右孩子的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;问题分析：&quot;&gt;&lt;a href=&quot;#问题分析：&quot; class=&quot;headerlink&quot; title=&quot;问题分析：&quot;&gt;&lt;/a&gt;问题分析：&lt;/h3&gt;&lt;p&gt;在二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历中，根结点的值在序列的中间，左子树的节点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此，需要扫描中序遍历序列，才能找到根结点的值。&lt;br&gt;通过上述步骤可以得到根结点以及左右子树的先序遍历序列和中序遍历序列，通过递归可以使用同样的方法分别构建左右子树。&lt;/p&gt;
&lt;h3 id=&quot;代码实现（C-C-）&quot;&gt;&lt;a href=&quot;#代码实现（C-C-）&quot; class=&quot;headerlink&quot; title=&quot;代码实现（C/C++）&quot;&gt;&lt;/a&gt;代码实现（C/C++）&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BinaryTreeNode* Construct(int* preoder,int* inorder,int length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(preorder==NULL || inorder==NULL || length&amp;lt;=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ConstructCore(preorder,preorder+length-1,inorder,inorder+length-1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BinaryTreeNode* ConstructCore(int* startPreorder, int* endPreorder,int* startInorder,int* endInorder)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //前序遍历序列中第一个结点为根结点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int rootValue=startPreorder[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BinaryTreeNode* root=new BinaryTreeNode();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;m_nValue=rootValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;m_pLeft=root-&amp;gt;m_pRight=NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(startPreorder==endPreoder)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(startInorder==endInorder &amp;amp;&amp;amp; *startPreorder==*startInorder)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            throw std::exception(&amp;quot;Invalid input.&amp;quot;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //中序遍历中找到根结点的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int* rootInorder=startInorder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(rootInorder&amp;lt;=endInorder &amp;amp;&amp;amp; *rootInorder!=rootValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ++rootInorder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(rootInorder==endInorder &amp;amp;&amp;amp; *rootInorder!=rootValue)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throw std::exception(&amp;quot;Invalid input.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int leftLength=rootInorder-startInorder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int* leftPreorderEnd=startPreorder+leftLength;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //构建左子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(leftLength&amp;gt;0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root-&amp;gt;m_pLeft=ConstructCore(startPreorder+1,leftPreorderEnd,startInorder,rootInorder-1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //构建右子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(leftLength&amp;lt;endPreorder-startPreorder)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root-&amp;gt;m_pRight=ConstructCore(leftPreorderEnd+1,endPreorder,rootInorder,endInorder);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里定义的ConstructCore中，先根据前序遍历序列中的第一个数字创建根结点，接下来在中序遍历中找到根结点的位置，这样就能确定左右子树结点的数量。在前序遍历和中序遍历中划分左右子树结构的值后，用ConstructCore递归地调用，构建左右子树。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序序列和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建该二叉树并返回它的头结点。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python学习笔记 如何理解__init__方法和self参数</title>
    <link href="http://WustChuiChui.github.io/2016/04/15/python-init-self/"/>
    <id>http://WustChuiChui.github.io/2016/04/15/python-init-self/</id>
    <published>2016-04-15T13:23:56.000Z</published>
    <updated>2016-04-15T13:53:48.274Z</updated>
    
    <content type="html">&lt;p&gt;学习Python的朋友肯定会经常接触到&lt;em&gt;init&lt;/em&gt;方法和self参数，那么Python中的&lt;strong&gt;init&lt;/strong&gt;方法和self参数分别指的是什么？又有什么意义呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Python学习笔记-如何理解init方法和self参数&quot;&gt;&lt;a href=&quot;#Python学习笔记-如何理解init方法和self参数&quot; class=&quot;headerlink&quot; title=&quot;Python学习笔记 如何理解init方法和self参数&quot;&gt;&lt;/a&gt;Python学习笔记 如何理解&lt;strong&gt;init&lt;/strong&gt;方法和self参数&lt;/h1&gt;&lt;h2 id=&quot;init方法&quot;&gt;&lt;a href=&quot;#init方法&quot; class=&quot;headerlink&quot; title=&quot;init方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;init&lt;/strong&gt;方法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;init&lt;/strong&gt;是在类创建的时候自动被执行的，这个函数在定义类的时候默认已经存在。&lt;br&gt;&lt;strong&gt;init&lt;/strong&gt;()方法意义重大的原因有两个。第一个原因是在对象生命周期中初始化是最重要的一步；每个对象必须正确初始化后才能正常工作。第二个原因是&lt;strong&gt;init&lt;/strong&gt;()参数值可以有多种形式。它的应用有两个：&lt;br&gt;&lt;strong&gt; 在超类中实现init() &lt;/strong&gt;&lt;br&gt;我们通过实现&lt;strong&gt;init&lt;/strong&gt;()方法来初始化对象。当一个对象被创建，Python首先创建一个空对象，然后为那个新对象调用&lt;strong&gt;init&lt;/strong&gt;()方法。这个方法函数通常用来创建对象的实例变量并执行任何其他一次性处理。&lt;br&gt;&lt;strong&gt; 使用init()创建显式常量 &lt;/strong&gt;&lt;br&gt;在某些情况下，我们会有一个在初始化或配置文件中创建的常量对象池，或者我们可以基于命令行参数显示创建常量对象，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class demon:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __init(self,name,symbol):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.name=name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.symbol=symbol&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，python的每个模块的包中，都存在一个&lt;strong&gt;init&lt;/strong&gt;.py文件(别和&lt;strong&gt;init&lt;/strong&gt;()方法弄混淆)，有了这个文件，我们才能导入这个目录下的module.&lt;br&gt;其实，&lt;strong&gt;init&lt;/strong&gt;.py里面还可以有其他内容，我们在导入一个包时，实际上导入了它的一个&lt;strong&gt;init&lt;/strong&gt;.py文件。&lt;br&gt;我们可以再在&lt;strong&gt;init&lt;/strong&gt;py文件中再导入其他的包，或者模块。&lt;br&gt;&lt;strong&gt;init&lt;/strong&gt;.py中海油一个重要的变量，叫做&lt;strong&gt;all&lt;/strong&gt;,可以使用它实现全部导入：&lt;br&gt;from PackageName import *&lt;/p&gt;
&lt;h2 id=&quot;self参数&quot;&gt;&lt;a href=&quot;#self参数&quot; class=&quot;headerlink&quot; title=&quot;self参数&quot;&gt;&lt;/a&gt;self参数&lt;/h2&gt;&lt;p&gt;Python的类的方法和普通的函数有一个很明显的区别，在类的方法必须有个额外的第一个参数 (self )，但在调用这个方法的时候不必为这个参数赋值 （显胜于隐 的引发）。Python的类的方法的这个特别的参数指代的是对象本身，而按照Python的惯例，它用self来表示。&lt;br&gt;self在Python里不是关键字，而是代表当前对象的一个实例。使用self能避免非限定调用造成的全局变量。&lt;br&gt;相信结果过C++的同学这时会想到C++中的this指针，self和this有着本质的区别，self代表的是一个对象的实例，this为指针，为当前对象的地址。但是在Python中将self改为this也不会报错，但为了书写规范，建议函数使用self.&lt;br&gt;对于self参数，需要注意三点：&lt;br&gt;self在定义时需要定义，但是在调用时会自动传入。&lt;br&gt;self的名字并不是规定死的，但是最好还是按照约定是用self&lt;br&gt;self总是指调用时的类的实例。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习Python的朋友肯定会经常接触到&lt;em&gt;init&lt;/em&gt;方法和self参数，那么Python中的&lt;strong&gt;init&lt;/strong&gt;方法和self参数分别指的是什么？又有什么意义呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>推荐系统概述</title>
    <link href="http://WustChuiChui.github.io/2016/04/15/Recomment-1/"/>
    <id>http://WustChuiChui.github.io/2016/04/15/Recomment-1/</id>
    <published>2016-04-15T11:29:09.000Z</published>
    <updated>2016-04-15T13:12:54.433Z</updated>
    
    <content type="html">&lt;p&gt;在互联网的发展历史上，最绚烂的成果当属搜索引擎。但通用的搜索引擎技术着力于对网络资源的大容量、无差别的获取和索引，并不能满足用户对于有偏好的信息检索的需求。原因之一是关键字的信息量不足，基于关键字的搜索在很多情况下不能精准和深刻地反映用户的潜在需求；原因二是通用的搜索引擎只有而且必须对用户提供尽量丰富而无差别的信息，这样才能应对不同种类的需求，并且需要的变化。基于上述问题，推荐系统应运而生。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;在世界范围内，推荐系统已经成为机器学习在电子商务和社交网站领域中最成功的应用之一。大多数有规模的电子商务网站都将推荐系统作为吸引和发掘客户的核心技术之一。&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 定义： &lt;/strong&gt;推荐系统是利用电子商务网站向客户提供商品信息和建议，帮助用户决定应该购买什么产品，模拟销售人员帮助客户完成购买过程。&lt;br&gt;推荐系统把用户模型中兴趣需求信息和推荐对象模型中的特征信息匹配，同时使用相应的推荐算法进行计算筛选，找到用户可能感兴趣的推荐对象，然后推荐给用户。&lt;br&gt;&lt;strong&gt; 和搜索引擎的异同： &lt;/strong&gt;&lt;br&gt;相同点：都是一种帮助用户快速发现有用信息的工具；&lt;br&gt;不同点：搜索引擎需要用户主动提供准确的关键词来寻找信息；推荐系统不需要用户提供明确的需求，而是通过分析用户的历史行为给用户的兴趣建模&lt;br&gt;联系：搜索引擎满足了用户有明确目的时的主动查找需求；推荐系统能够在用户没有明确目的的时候帮助他们发现感兴趣的新内容；从这种意义上讲，推荐系统和搜索引擎对于用户来说是两个互补的工具。&lt;/p&gt;
&lt;h2 id=&quot;推荐系统的组成&quot;&gt;&lt;a href=&quot;#推荐系统的组成&quot; class=&quot;headerlink&quot; title=&quot;推荐系统的组成&quot;&gt;&lt;/a&gt;推荐系统的组成&lt;/h2&gt;&lt;h3 id=&quot;用户建模模块&quot;&gt;&lt;a href=&quot;#用户建模模块&quot; class=&quot;headerlink&quot; title=&quot;用户建模模块&quot;&gt;&lt;/a&gt;用户建模模块&lt;/h3&gt;&lt;p&gt;用户模型的建模方法主要有遗传算法、基于机器学习的方法，如TF-IDF、自动聚类、贝叶斯分类器、决策树归纳和神经网络方法。&lt;br&gt;建模的对象有单用户建模和群组建模之分，单用户建模针对单个用户进行建模，比如基于内容的推荐；群组建模是针对群体用户进行建模，比如协同推荐&lt;br&gt;&lt;strong&gt; 用户模型应该具备以下特征： &lt;/strong&gt;&lt;br&gt;能获取、表示、存储和修改用户兴趣偏好，能进行推理；&lt;br&gt;对用户进行分类和识别；&lt;br&gt;帮助系统更好地理解用户特征和类别，理解用户的需求和任务，从而更好地实现用户所需要的功能；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 建立用户模型前要考虑的问题： &lt;/strong&gt;&lt;br&gt;模型的输入数据有哪些，如何获取模型的输入数据；&lt;br&gt;如何考虑用户的兴趣及需求的变化；&lt;br&gt;建模的对象是谁；&lt;br&gt;清楚了上述内容后，如何建模；&lt;br&gt;模型的输出是什么；&lt;/p&gt;
&lt;h3 id=&quot;推荐对象建模模块&quot;&gt;&lt;a href=&quot;#推荐对象建模模块&quot; class=&quot;headerlink&quot; title=&quot;推荐对象建模模块&quot;&gt;&lt;/a&gt;推荐对象建模模块&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; 建立对象模型需要考虑的问题： &lt;/strong&gt;&lt;br&gt;提取推荐对象的什么特征，如何提取，提取的特征用于什么目的；&lt;br&gt;对象的特征描述和用户文件描述之间有关联；&lt;br&gt;提取到的每个对象特征对推荐结果有何影响；&lt;br&gt;对象的特征描述文件是否能自动更新。&lt;/p&gt;
&lt;p&gt;不同的对象，特征也不相同，目前没有一个统一的标准来进行统一描述，主要有基于内容的方法和基于分类的方法两大类方法。&lt;br&gt;基于内容的方法是从对象本身抽取信息来表示对象，使用最广泛的方法是用加权关键字矢量。目前使用最广泛的是TF-IDF方法。&lt;br&gt;基于分类的方法是把推荐对象放入不同类别中，这样可以把同类文档推荐给该类文档感兴趣的用户。相关方法有朴素贝叶斯，k最邻方法和支持向量机。&lt;/p&gt;
&lt;p&gt;推荐系统推荐给用户的对象首先不能与用户看过的对象重复，其次也不能与用户刚刚看过的对象不是太形似或者太不相关，即&lt;strong&gt; 模型过拟合 &lt;/strong&gt;问题。&lt;/p&gt;
&lt;p&gt;推荐系统中出现新的对象是，推荐系统尤其是协同过滤系统中，对象出现后必须等一段时间才有用户查看并进行评价，在此之前推荐系统无法对此对象进行分析和推荐，这就是推荐系统的难点问题——&lt;strong&gt;冷启动问题。 &lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;推荐算法模块&quot;&gt;&lt;a href=&quot;#推荐算法模块&quot; class=&quot;headerlink&quot; title=&quot;推荐算法模块&quot;&gt;&lt;/a&gt;推荐算法模块&lt;/h3&gt;&lt;p&gt;推荐算法是整个推荐系统中最核心的部分，很大程度上决定了推荐系统的性能的优劣&lt;br&gt;推荐算法主要包括以下几种：&lt;br&gt;&lt;strong&gt; 基于内容的推荐 &lt;/strong&gt;&lt;br&gt;根据用户已经选择的对象，从推荐对象中选择其他特征相似的对象作为推荐结果，首先提取推荐对象的内容特征，和用户模型中的用户兴趣偏好匹配，匹配度较高的推荐对象最推荐结果推荐给用户，如下图&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006qSkuxgw1f2xormc9kmj30c506kwez.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt; 协同过滤推荐 &lt;/strong&gt;&lt;br&gt;这里暂不展开说明，在下一篇博客中做详细介绍&lt;br&gt;&lt;strong&gt; 基于知识的推荐 &lt;/strong&gt;&lt;br&gt;如果把注意力头像其他应用领域，比如消费类电子产品，会设计大量的单次购买者，这意味着推荐系统无法依赖购买记录，此时需要利用额外的因果知识生成推荐&lt;br&gt;&lt;strong&gt; 混合推荐 &lt;/strong&gt;&lt;br&gt;混合推荐的目的是通过组合不同的推荐策略，达到扬长避短的效果，从而产生更符合用户需求的推荐，目前亚马逊采用的就是混合推荐算法&lt;/p&gt;
&lt;h3 id=&quot;开源的推荐系统简介&quot;&gt;&lt;a href=&quot;#开源的推荐系统简介&quot; class=&quot;headerlink&quot; title=&quot;开源的推荐系统简介&quot;&gt;&lt;/a&gt;开源的推荐系统简介&lt;/h3&gt;&lt;p&gt;这里不一一举例说明，有兴趣可以参考开源中国社区&amp;gt;&lt;a href=&quot;http://www.oschina.net/news/51297/top-10-open-source-recommendation-systems&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.oschina.net/news/51297/top-10-open-source-recommendation-systems&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在互联网的发展历史上，最绚烂的成果当属搜索引擎。但通用的搜索引擎技术着力于对网络资源的大容量、无差别的获取和索引，并不能满足用户对于有偏好的信息检索的需求。原因之一是关键字的信息量不足，基于关键字的搜索在很多情况下不能精准和深刻地反映用户的潜在需求；原因二是通用的搜索引擎只有而且必须对用户提供尽量丰富而无差别的信息，这样才能应对不同种类的需求，并且需要的变化。基于上述问题，推荐系统应运而生。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>决策树算法之——CART</title>
    <link href="http://WustChuiChui.github.io/2016/04/14/scikit-learn-CART/"/>
    <id>http://WustChuiChui.github.io/2016/04/14/scikit-learn-CART/</id>
    <published>2016-04-14T13:43:18.000Z</published>
    <updated>2016-04-14T14:40:45.235Z</updated>
    
    <content type="html">&lt;p&gt;CART(Classfication and Regression Tree)算法是目前决策树算法最为成熟的一类算法，应用范围比较广泛。它既可用于分类，也可以用于预测。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;一、回归算法原理&quot;&gt;&lt;a href=&quot;#一、回归算法原理&quot; class=&quot;headerlink&quot; title=&quot;一、回归算法原理&quot;&gt;&lt;/a&gt;一、回归算法原理&lt;/h2&gt;&lt;p&gt;在预测中，CART使用最小剩余方差(Squared Residuals Minimization)来判定回归树的最优划分，这个准则期望划分之后的子树与样本点的误差方差最小。这样决策树的将数据集切成很多子模型数据，然后利用线性回归技术来建模。如果每次切分后的数据仍然难以拟合，就继续切分。在这种切分方式下创建预测树，每个叶子节点都是一个线性回归模型。这些线性回归模型反映了样本集合中蕴含的模式，也称模型树。&lt;br&gt;CART不仅支持整体预测，也支持局部模式的预测，并有能力从整体中找到模式，或根据模式组合成一个整体。整体和模式之间的相互结合，对于预测分析具有十分重要的意义。&lt;/p&gt;
&lt;h2 id=&quot;二、算法流程&quot;&gt;&lt;a href=&quot;#二、算法流程&quot; class=&quot;headerlink&quot; title=&quot;二、算法流程&quot;&gt;&lt;/a&gt;二、算法流程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 决策树主函数： &lt;/strong&gt;决策树的主函数是一个递归函数。主要用来按CART的规则生长出决策树的各个分支节点，并根据终止条件结束算法：&lt;br&gt;1）输入需要分类的数据集合类别标签。&lt;br&gt;2）使用最小剩余方差法判定回归树的最优划分，并创建特征的划分节点——最小剩余方差子函数。&lt;br&gt;3)在划分节点划分数据集为两部分——二分数据集子函数。&lt;br&gt;4）根据二分数据的结果创建出新的左、右节点，作为树生长的两个分支。&lt;br&gt;5）检验是否符合递归的终止条件。&lt;br&gt;6）将划分的新节点包含的数据集合类别标签作为输入，递归执行上述步骤。&lt;br&gt;&lt;strong&gt; 使用最小剩余方差子函数 &lt;/strong&gt;，计算数据集各列的最优划分方差，划分列，划分值。&lt;br&gt;&lt;strong&gt; 二分数据集： &lt;/strong&gt;根据给定的分隔列和分隔值将数据集一分为二，分别返回。&lt;br&gt;&lt;strong&gt; 剪枝策略： &lt;/strong&gt;使用先剪枝和后剪枝策略对计算出的决策树进行剪枝。&lt;/p&gt;
&lt;h2 id=&quot;三、最小剩余方差法&quot;&gt;&lt;a href=&quot;#三、最小剩余方差法&quot; class=&quot;headerlink&quot; title=&quot;三、最小剩余方差法&quot;&gt;&lt;/a&gt;三、最小剩余方差法&lt;/h2&gt;&lt;p&gt;CART选择最优划分点的方法，首先求取划分数据列的均值和总方差。总方差的计算方法有两种：&lt;br&gt;1.求取均值std,计算每个数据点与std的方差，然后将n个点求和。&lt;br&gt;2.求取方差var,然后var_sum=var*n，n为数据集数据数目。&lt;br&gt;对应地，每次最佳分支特征的选取过程如下：&lt;br&gt;(1)先令最佳方差为无限大bestVar=inf;&lt;br&gt;(2)依次遍历所有特征列及每个特征列的所有样本点，在每个样本点上二分数据集；&lt;br&gt;(3)计算二分数据集后的总方差currentVar（划分后左右子数据集的总方差之和），如果currentVar&amp;lt; bestVar,则bestVar=currentVar&lt;br&gt;(4)返回计算的最优分支特征列、分支特征值（连续特征则为划分点的值），以及左右分支子数据集到主程序。&lt;/p&gt;
&lt;h2 id=&quot;四、模型树&quot;&gt;&lt;a href=&quot;#四、模型树&quot; class=&quot;headerlink&quot; title=&quot;四、模型树&quot;&gt;&lt;/a&gt;四、模型树&lt;/h2&gt;&lt;p&gt;模型树具有很多优秀的性质，它包含了如下的特性：&lt;br&gt;1）一般而言，样本总体的重复性不会很高，但局部模式经常重复。类似于历史不会重复，但会重演；&lt;br&gt;2）模型给出了数据的范围，它可能是一个时间范围，也可以是一个空间范围；而且模型还给出变化的趋势，可以是曲线，也可以是直线，这依赖于使用的回归算法；&lt;br&gt;3）传统的回归方法，无论是线性回归还是非线性回归，都不如模型树包含的信息丰富，模型树具有更高的预测准确度。&lt;/p&gt;
&lt;h2 id=&quot;五、剪枝策略&quot;&gt;&lt;a href=&quot;#五、剪枝策略&quot; class=&quot;headerlink&quot; title=&quot;五、剪枝策略&quot;&gt;&lt;/a&gt;五、剪枝策略&lt;/h2&gt;&lt;p&gt;因为使用了连续的数据，CART可以生长出大量的分支树，为了避免过拟合的问题，预测树采用了剪枝的方法。剪枝方法主要包括先剪枝和后剪枝。&lt;br&gt;&lt;strong&gt; 先剪枝： &lt;/strong&gt; 给出一个预定义的划分阈值，当节点的划分子集某个标准低于预定义的阈值时，子集划分将终止。&lt;strong&gt; 选取合适的阈值比较困难，过高将导致过拟合，过低将导致欠拟合。它的优势是不必生成整棵决策树，算法简单，效率高，适合大规模问题的粗略估计 &lt;/strong&gt;&lt;br&gt;&lt;strong&gt; 后剪枝： &lt;/strong&gt; 后剪枝指在完全生成的决策树上，根据一定的规则标准，减掉树中不具备一般代表性的子树，使用叶子节点替代。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;CART(Classfication and Regression Tree)算法是目前决策树算法最为成熟的一类算法，应用范围比较广泛。它既可用于分类，也可以用于预测。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python与机器学习  C4.5决策树算法</title>
    <link href="http://WustChuiChui.github.io/2016/04/14/C4-5-Tree-classfication/"/>
    <id>http://WustChuiChui.github.io/2016/04/14/C4-5-Tree-classfication/</id>
    <published>2016-04-14T12:23:53.000Z</published>
    <updated>2016-04-14T14:40:59.375Z</updated>
    
    <content type="html">&lt;p&gt;针对ID3算法存在的一些问题，Quinlan将ID3改进为C4.5算法，该算法成功地解决了ID3算法遇到的诸多问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;信息增益率&quot;&gt;&lt;a href=&quot;#信息增益率&quot; class=&quot;headerlink&quot; title=&quot;信息增益率&quot;&gt;&lt;/a&gt;信息增益率&lt;/h2&gt;&lt;p&gt;C4.5并没有改变ID3的算法逻辑，基本的程序结构仍与ID3相同，但在节点的划分标准做了改进。&lt;strong&gt; C4.5使用信息增益率来替代信息增益进行特征选择，克服了信息增益选择特征时偏向于特征值个数较多的不足。 &lt;/strong&gt;信息增益率的定义为：&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006qSkuxgw1f2winq2g3nj30df02hdg3.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;其中Gain(S,A)就是ID3算法中的信息增益，而划分信息SplitInfo(S,A)代表了按照特征A划分样本集S的广度和均匀性。&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006qSkuxgw1f2wivjwy58j30dq02qweo.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;其中，Si到S是特征A的C个不同值构成的样本子集。&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h2&gt;&lt;p&gt;C4.5在节点的划分标准上做了改进，代码部分很大程度上没有改动。&lt;br&gt;(1) 使用信息增益率划分最优节点的方法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def getBestFeat(self,dataSet):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Num_Feats=len(dataSet[0][:-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	totality=len(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BaseEntropy=self.computeEntropy(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ConditionEntropy=[]    #初始化条件熵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sliptInfo=[]           #计算增长率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	allFeatVList=[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for f in xrange(Num_Feats):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		featList=[example[f] for example in dataSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		[splitI,featureValueList]=self.computeSplitInfo(featList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		allFeatVList.append(splitI)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		resultGain=0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		for value in featureValueList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			subSet=self.splitDataSet(dataSet,f,value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			appearNum=float(len(subSet))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			subEntropy=self.computeEntropy(subSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			resultGain+=(appearNum/totality)*subEntropy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ConditionEntropy.append(resultGain)   #总条件熵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	infoGainArray=BaseEntropy*ones(Num_Feats)-array(ConditionEntropy)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	infoGainRatio=infoGainArray/array(sliptInfo)   #信息增长率的计算&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bestFeatureIndex=argsort(-infoGainRatio)[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return bestFeatureIndex,allFeatVList[bestFeatureIndex]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(2)计算划分信息（SplitInfo）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def computeSplitInfo(self,featureVList):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	numEntries=len(featureVList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	featureVauleSetList=list(set(featureVList))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	valueCounts=[featureVList.count(featVec) for featVec in featureVauleSetList]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	pList=[float(item)/numEntries for item in valueCounts]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	lList=[item*math.log(item,2) for item in pList]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	splitInfo=-sum(lList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return splitInfo,featureVauleSetList&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(3)决策树函数&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def builtTree(self,dataSet,labels):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cateList=[data[-1] for data in dataSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if cateList.count(cateList[0])==len(cateList):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return cateList[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if len(dataSet[0])==1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return self.maxCate(cateList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bestFeat,featureValueList=self.getBestFeat(dataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bestFeatLabel=labels[bestFeat]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tree=&amp;#123;bestFeatLabel:&amp;#123;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	del(labels[bestFeat])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for value in featureValueList:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		subLabels=labels[:]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		splitDataSet=self.splitDataSet(dataSet,bestFeat,value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		subTree=self.builtTree(splitDataSet,subLabels)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		tree[bestFeatLabel][value]=subTree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return tree&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;针对ID3算法存在的一些问题，Quinlan将ID3改进为C4.5算法，该算法成功地解决了ID3算法遇到的诸多问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ID3决策树算法的实现（Python）</title>
    <link href="http://WustChuiChui.github.io/2016/04/14/achieve-ID3/"/>
    <id>http://WustChuiChui.github.io/2016/04/14/achieve-ID3/</id>
    <published>2016-04-14T08:54:29.000Z</published>
    <updated>2016-04-14T08:58:14.130Z</updated>
    
    <content type="html">&lt;p&gt;ID3算法是一种贪心算法，用来构造决策树。ID3算法起源于概念学习系统（CLS），以信息熵的下降速度为选取测试属性的标准，即在每个节点选取还尚未被用来划分的具有最高信息增益的属性作为划分标准，然后继续这个过程，直到生成的决策树能完美分类训练样例.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;ID3决策树算法的实现（Python）&quot;&gt;&lt;a href=&quot;#ID3决策树算法的实现（Python）&quot; class=&quot;headerlink&quot; title=&quot;ID3决策树算法的实现（Python）&quot;&gt;&lt;/a&gt;ID3决策树算法的实现（Python）&lt;/h1&gt;&lt;p&gt;这里主要给出ID3算法的实现代码，关于ID3算法的介绍，可参考本人的博客&amp;gt;&lt;a href=&quot;https://wustchuichui.github.io/2016/04/14/ID3-Tree/&quot;&gt;https://wustchuichui.github.io/2016/04/14/ID3-Tree/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from numpy import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import math&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import copy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import cPickle as pickle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class ID3DTree(object):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __init__(self):     #构造方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tree=&amp;#123;&amp;#125;        #生成的树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.dataSet=[]     #数据集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.lables=[]      #标签集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #数据导入函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def loadDataSet(self,path,lables):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        recordlist=[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fp=open(path,&amp;quot;rb&amp;quot;)  #读取文件内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        content=fp.read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fp.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rowlist=content.splitlines()     #按行转换为一维表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        recordlist=[row.split(&amp;quot;\t&amp;quot;) for row in rowlist if row.strip()]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.dataSet=recordlist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.lables=lables&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #执行决策函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def train(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lables=copy.deepcopy(self.lables)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tree=self.buildTree(self.dataSet,lables)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #构建决策树，创建决策树主程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def buildTree(self,dataSet,lables):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cateList=[data[-1] for data in dataSet]   #抽取源数据集中的决策标签列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #程序终止条件1：如果classList只有一种决策标签，停止划分，返回这个决策标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if cateList.count(cateList[0])==len(cateList):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return cateList[0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #程序终止条件2：如果数据集的第一个决策标签只有一个，返回这个标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if len(dataSet[0])==1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return self.maxCate(cateList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #核心部分&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bestFeat=self.getBestFeat(dataSet) #返回数据集的最优特征轴&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bestFeatLabel=lables[bestFeat]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tree=&amp;#123;bestFeatLabel:&amp;#123;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        del(lables[bestFeat])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #抽取最优特征轴的列向量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        uniqueVals=set([data[bestFeat] for data in dataSet])  #去重&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for value in uniqueVals:          #决策树递归生长&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            subLables=lables[:]           #将删除后的特征类别集建立子类别集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #按最优特征列和值分隔数据集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            splitDataset=self.splitDataset(dataSet,bestFeat,value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            subTree=self.buildTree(splitDataset,subLables)  #构建子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tree[bestFeatLabel][value]=subTree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return tree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #计算出现次数最多的类别标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def maxCate(self,cateList):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        items=dict([(cateList.count(i),i) for i in cateList])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return items[max(items.keys())]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #计算最优特征&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def getBestFeat(self,dataSet):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #计算特征向量维，其中最后一列用于类别标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        numFeatures=len(dataSet[0])-1  #特征向量维数=行向量维数-1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        baseEntropy=self.computeEntropy(dataSet) #基础熵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bestInfoGain=0.0         #初始化最优的信息增益&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bestFeature=-1           #初始化最优的特征轴&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #外循环：遍历数据集各列，计算最优特征轴&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #i为数据集列索引：取值范围0~(numFeatures-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for i in xrange(numFeatures):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            uniqueVals=set([data[i] for data in dataSet]) #去重&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            newEntropy=0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for value in uniqueVals:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                subDataSet=self.splitDataSet(dataSet,i,value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                prob=len(subDataSet)/float(len(dataSet))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                newEntropy+=prob*self.computeEntropy(subDataSet)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            infoGain=baseEntropy-newEntropy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(infoGain&amp;gt;bestInfoGain):  #信息增益大于0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestInfoGain=infoGain   #用当前信息增益值替代之前的最优增益值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                bestFeature=i           #重置最优特征为当前列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return bestFeature&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #计算信息熵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def computeEntropy(self,dataSet):   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        datalen=float(len(dataSet))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cateList=[data[-1] for data in dataSet]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #得到类别为key、出现次数value的字典&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        items=dict([(i,cateList.count(i)) for i in cateList])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infoEntropy=0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for key in items:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            prob=float(items[key])/datalen&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            infoEntropy-=prob*math.log(prob,2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return infoEntropy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #划分数据集；分隔数据集；删除特征轴所在的数据列，返回剩余的数据集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #dataSet:数据集；axis:特征轴；value:特征轴的取值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def splitDataSet(self,dataSet,axis,value):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        rtnList=[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for featVec in dataSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if featVec[axis]==value:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rFeatVec=featVec[:axis]    #list操作：提取0~（axis-1）的元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rFeatVec.extend(featVec[axis+1:])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rtnList.append(rFeatVec)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return rtnList&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;ID3算法是一种贪心算法，用来构造决策树。ID3算法起源于概念学习系统（CLS），以信息熵的下降速度为选取测试属性的标准，即在每个节点选取还尚未被用来划分的具有最高信息增益的属性作为划分标准，然后继续这个过程，直到生成的决策树能完美分类训练样例.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>决策树的发展 信息熵和ID3</title>
    <link href="http://WustChuiChui.github.io/2016/04/14/ID3-Tree/"/>
    <id>http://WustChuiChui.github.io/2016/04/14/ID3-Tree/</id>
    <published>2016-04-14T05:59:20.000Z</published>
    <updated>2016-04-14T07:46:00.014Z</updated>
    
    <content type="html">&lt;p&gt;决策树算法是最早的机器学习算法之一。ID3的一个分支是分类回归决策树算法（Classification and Regression Tree,CART）。CART决策树主要用于预测分析。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;决策树的发展-信息熵和ID3&quot;&gt;&lt;a href=&quot;#决策树的发展-信息熵和ID3&quot; class=&quot;headerlink&quot; title=&quot;决策树的发展 信息熵和ID3&quot;&gt;&lt;/a&gt;决策树的发展 信息熵和ID3&lt;/h1&gt;&lt;h2 id=&quot;一、基本思想&quot;&gt;&lt;a href=&quot;#一、基本思想&quot; class=&quot;headerlink&quot; title=&quot;一、基本思想&quot;&gt;&lt;/a&gt;一、基本思想&lt;/h2&gt;&lt;p&gt;决策树的思想来源非常朴素，在程序设计中，最基本的语句条件分支结构就是if-then结构，最早的决策树就是利用这类结构分隔数据的一种分类学习方法。&lt;/p&gt;
&lt;h2 id=&quot;二、算法框架&quot;&gt;&lt;a href=&quot;#二、算法框架&quot; class=&quot;headerlink&quot; title=&quot;二、算法框架&quot;&gt;&lt;/a&gt;二、算法框架&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 1.决策树主函数 &lt;/strong&gt;&lt;br&gt;决策树主函数本质上是一个递归函数，它按某种规则生长出决策树的分支节点，并根据终止条件结束算法。它需要完成以下几个功能：&lt;br&gt;（1）输入需要分类的数据集和类别标签；&lt;br&gt;（2）根据某种分类规则得到最优化的划分特征，并创建特征的划分节点——计算最优化特征子函数；&lt;br&gt;（3）按照划分子函数的计算结果构建新的节点——划分数据集子函数；&lt;br&gt;（4）根据划分子函数的计算结果构建出新的节点，作为树生长出的新分支；&lt;br&gt;（5）检验是否符合递归的终止条件；&lt;br&gt;（6）将划分的新节点包含的数据集和类别标签作为输入，递归执行上述步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2.计算最优特征子函数 &lt;/strong&gt;&lt;br&gt;计算最优特征子函数是除了主函数外最重要的函数。&lt;strong&gt; 最优特征选择的标准上的差异性将导致不同决策树之间的差异性。 &lt;/strong&gt;&lt;br&gt;ID3的最优特征选择标准是：&lt;strong&gt; 信息增益 &lt;/strong&gt;&lt;br&gt;C4.5的最优特征选择标准是：&lt;strong&gt; 信息增益率 &lt;/strong&gt;&lt;br&gt;CART的最优特征选择标准是：&lt;strong&gt; 节点方差大小 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.划分数据集函数 &lt;/strong&gt;&lt;br&gt;划分数据集函数的主要功能是分隔数据集，有的需要删除某个特征轴所在的数据列，返回剩余的数据集；有的干脆将数据一分为二等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.分类器 &lt;/strong&gt;&lt;br&gt;所有的机器学习都要用于分类或回归预测，决策树的分类器就是通过遍历整个决策树，使得测试数据集找到决策树中的叶子节点对应的类别标签，也就是返回的类别结果。&lt;/p&gt;
&lt;h2 id=&quot;三、信息熵&quot;&gt;&lt;a href=&quot;#三、信息熵&quot; class=&quot;headerlink&quot; title=&quot;三、信息熵&quot;&gt;&lt;/a&gt;三、信息熵&lt;/h2&gt;&lt;p&gt;熵是用来表示任何一种能量在空间中的均匀程度。能量分布得越均匀，熵越大。信息指的是对不确定性的消除。信息熵是事物不确定性的度量标准，也称为信息的单位或“测度”。信源的平均不确定性应当为单个符号不确定性的统计平均值(E),可称为信息熵，即 :&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006qSkuxgw1f2w8t0ea0sj30db02974c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;假设S是s个数据样本的集合。假定类别标签具有m个不同值，定义m个不同类Ci(i=1,2,3,…m).设si是类Ci中样本数。对给定的样本分类所需要的信息熵由下式给出：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006qSkuxgw1f2w90g8dvsj30cz02haa4.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;其中pi是任意样本属于Ci的概率，用si/S估计。&lt;br&gt;设A具有v个不同值{a1,a2,…av}.A将S划分为v个子集{S1,S2,…,Sv}。Sj包含S中这样一些样本：他们在A上具有值aj.如果选A作测试特征，即最优划分特征，由A划分成子集的熵或期望信息由下式给出：&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006qSkuxgw1f2w9cn1nnnj30i102imxe.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在ID3决策树算法中，使用信息增益确定决策树分支的划分标准。它是决策树某个分支上整个数据集信息熵与当前节点信息熵的差值，即：&lt;br&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006qSkuxgw1f2w9k7hwf7j30ce01aweh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、ID3决策树&quot;&gt;&lt;a href=&quot;#四、ID3决策树&quot; class=&quot;headerlink&quot; title=&quot;四、ID3决策树&quot;&gt;&lt;/a&gt;四、ID3决策树&lt;/h2&gt;&lt;p&gt;ID3决策树生成过程如下：&lt;br&gt;（1）计算给定样本分类所需的信息熵；&lt;br&gt;（2）计算每个特征的信息熵；&lt;br&gt;（3）从所有的特征列中选出信息增益量最大的那个作为根节点或内部节点——划分节点，划分整列，首次递归选择列来划分。&lt;br&gt;（4）根据划分节点的不同取值来拆分数据集为若干个子集，然后删去当前的特征列，再计算剩余特征列的信息熵。如果有信息增益，就重复第二步直至划分结束。&lt;br&gt;（5）划分结束的标志为：子集中一个类别标签，停止划分。&lt;/p&gt;
&lt;h2 id=&quot;五、算法评估&quot;&gt;&lt;a href=&quot;#五、算法评估&quot; class=&quot;headerlink&quot; title=&quot;五、算法评估&quot;&gt;&lt;/a&gt;五、算法评估&lt;/h2&gt;&lt;p&gt;它以信息熵为度量标准，划分出决策树特征节点，每次优先选取信息量最多的属性，也就是使信息熵变为最小的属性，以构造一棵信息熵下降最快的决策树。&lt;br&gt;ID3存在的一些问题：&lt;br&gt;1）ID3算法的节点划分度量标准采用的是信息增益，信息增益偏向于选择特征值个数较多的特征。而取值个数较多的特征并不一定是最优的特征，所以需要改进选择属性的节点划分度量标准。&lt;br&gt;2）算法递归实现过程中要依次计算每个特征值，对于大型数据会生成比较复杂的决策树：层次和分支都很多，而其中某些分支的特征值概率很小，容易造成过拟合问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;决策树算法是最早的机器学习算法之一。ID3的一个分支是分类回归决策树算法（Classification and Regression Tree,CART）。CART决策树主要用于预测分析。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python与机器学习 K近邻算法及实现</title>
    <link href="http://WustChuiChui.github.io/2016/04/13/K-Nearest-Neighbor/"/>
    <id>http://WustChuiChui.github.io/2016/04/13/K-Nearest-Neighbor/</id>
    <published>2016-04-13T02:11:04.000Z</published>
    <updated>2016-04-13T03:11:39.975Z</updated>
    
    <content type="html">&lt;p&gt;通过计算向量间的距离衡量相似度来实现分类，就是k-NN(k-Nearest Neighbor)算法，一种基于向量间相似度的分类算法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Python与机器学习-K近邻算法及实现&quot;&gt;&lt;a href=&quot;#Python与机器学习-K近邻算法及实现&quot; class=&quot;headerlink&quot; title=&quot;Python与机器学习 K近邻算法及实现&quot;&gt;&lt;/a&gt;Python与机器学习 K近邻算法及实现&lt;/h1&gt;&lt;h2 id=&quot;一、算法原理&quot;&gt;&lt;a href=&quot;#一、算法原理&quot; class=&quot;headerlink&quot; title=&quot;一、算法原理&quot;&gt;&lt;/a&gt;一、算法原理&lt;/h2&gt;&lt;p&gt;k-最近邻（k-Nearest Neighbor）算法是一种较简单的机器学习算法。它采用测量不同特征值之间的距离方法进行分类。它的基本思想如下：如果一个样本在特征空间中的k个最近邻的样本中的大多数都属于某一个类别，则该样本也属于这个类别。&lt;br&gt;&lt;strong&gt; 算法流程： &lt;/strong&gt;&lt;br&gt;第一阶段：确定k值（最近邻居的个数），一般为一个奇数。&lt;br&gt;第二阶段：确定距离度量公式，文本分类一般使用&lt;strong&gt; 余弦夹角 &lt;/strong&gt;进行度量。&lt;br&gt;第三阶段：统计k个样本点中各个类别的数量，根据k各样本中数量最多的样本的类别确定输入数据的类别。&lt;/p&gt;
&lt;h2 id=&quot;二、算法评估&quot;&gt;&lt;a href=&quot;#二、算法评估&quot; class=&quot;headerlink&quot; title=&quot;二、算法评估&quot;&gt;&lt;/a&gt;二、算法评估&lt;/h2&gt;&lt;p&gt;&lt;strong&gt; 优点： &lt;/strong&gt;&lt;br&gt;1.简单，易于理解，无需估计参数，无需训练；&lt;br&gt;2.适合对稀有事件进行分类；&lt;br&gt;3.特别适合于多分类问题，在此领域k-NN比SVM表现要好。&lt;br&gt;&lt;strong&gt; 缺点： &lt;/strong&gt;&lt;br&gt;1.样本不平衡时，可能会影响分类结果；&lt;br&gt;2.计算量相对较大，原因是对每一个样本，都要计算它到全体样本的距离；&lt;br&gt;3.可理解性差，无法给出类似于决策树那样的规则。&lt;/p&gt;
&lt;h2 id=&quot;三、Python实现&quot;&gt;&lt;a href=&quot;#三、Python实现&quot; class=&quot;headerlink&quot; title=&quot;三、Python实现&quot;&gt;&lt;/a&gt;三、Python实现&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#第一阶段：导入所需的库，进行数据的初始化。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import os&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;from numpy import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import numpy as np &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import operator&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;from Nbayes_lib import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#配准UTF-8输出环境&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reload(sys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sys.setdefaultencoding(&amp;apos;utf-8&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;k=3   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#第二阶段：实现夹角余弦的距离公式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def cosdist(vector1,voctor2):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return dot(vector1,voctor2)/(linalg.norm(vector1)*linalg.norm(voctor2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#第三阶段：kNN实现分类器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#测试集：testdata; 训练集：trainSet; 类别标签：listClasses; k：k个近邻数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;def classify(testdata,trainSet,listClasses,k):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataSetSize=trainSet.shape[0]   #样本集的行数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    distances=array(zeros(dataSetSize))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for indx in xrange(dataSetSize):   #计算测试集与训练集之间的距离：余弦夹角&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        distances[indx]=cosdist(testdata,trainSet[indx])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sortedDistIndicies=argsort(-distances)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classCount=&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for i in range(k):     #获取角度最小的前k项作为参考项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        #按排序顺序返回样本集对应的类别标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        voteIkabel=listClasses[sortedDistIndicies[i]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clssCount[voteIkabel]=classCount.get(voteIkabel,0)+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #对分类字典按value排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sorted(data.iteritems(),key=operator.itemgetter(1),reverse=True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #该句按字典值排序的固定用法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sortedClassCount=sorted(classCount.iteritems(),key=operator.itemgetter(1),reverse=True)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return sortedClassCount[0][0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;四、改进策略&quot;&gt;&lt;a href=&quot;#四、改进策略&quot; class=&quot;headerlink&quot; title=&quot;四、改进策略&quot;&gt;&lt;/a&gt;四、改进策略&lt;/h2&gt;&lt;p&gt;k-NN算法的改进主要分为分类效率和分类效果两个方面：&lt;br&gt;&lt;strong&gt; 分类效率： &lt;/strong&gt;事先对样本属性进行约简，删除对分类结果影响较小的属性，快速的得出待分类样本的类别。该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。&lt;br&gt;&lt;strong&gt; 分类效果： &lt;/strong&gt;采用权值的方法（和该样本距离小的邻居权值大）来改进该算法，由于不同分类的文件本身有数量上差异，因此也可以选取不同数目的最近邻居，来参考分类。&lt;/p&gt;
&lt;h2 id=&quot;五、相关工具箱&quot;&gt;&lt;a href=&quot;#五、相关工具箱&quot; class=&quot;headerlink&quot; title=&quot;五、相关工具箱&quot;&gt;&lt;/a&gt;五、相关工具箱&lt;/h2&gt;&lt;p&gt;MATLAB：MATLAN 2016版集成了机器学习和深度学习相关的工具箱，其中DeepLearnToolbox-master中包含k-N等多种算法；&lt;br&gt;Python: scikit-learn 库中有该函数的实现&lt;br&gt;C++:CSDN 上有C++版的代码实现&lt;br&gt;R语言：&amp;gt;&lt;a href=&quot;http://blog.csdn.net/liulewei/article/details/8288412&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/liulewei/article/details/8288412&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通过计算向量间的距离衡量相似度来实现分类，就是k-NN(k-Nearest Neighbor)算法，一种基于向量间相似度的分类算法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树的几种遍历算法及其实现（C/C++）</title>
    <link href="http://WustChuiChui.github.io/2016/04/12/visit-binary-tree/"/>
    <id>http://WustChuiChui.github.io/2016/04/12/visit-binary-tree/</id>
    <published>2016-04-12T13:41:45.000Z</published>
    <updated>2016-04-13T01:20:34.986Z</updated>
    
    <content type="html">&lt;p&gt;二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树的子树有左右之分，次序不能颠倒。这里对二叉树的几种遍历算法做一下整理，供大家学习。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;二叉树的几种遍历算法及其实现（C-C-）&quot;&gt;&lt;a href=&quot;#二叉树的几种遍历算法及其实现（C-C-）&quot; class=&quot;headerlink&quot; title=&quot;二叉树的几种遍历算法及其实现（C/C++）&quot;&gt;&lt;/a&gt;二叉树的几种遍历算法及其实现（C/C++）&lt;/h1&gt;&lt;h2 id=&quot;基本结构&quot;&gt;&lt;a href=&quot;#基本结构&quot; class=&quot;headerlink&quot; title=&quot;基本结构&quot;&gt;&lt;/a&gt;基本结构&lt;/h2&gt;&lt;p&gt;二叉树一般采用链式存储结构，结构体中包括data域和两个子树的指针域，其定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct BiTNode&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int data;  //数据域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	struct BiTNode *lchild; //左子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	struct BiTNode *rchild; //右子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;BiTNode,*BiTree;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;二叉树的遍历&quot;&gt;&lt;a href=&quot;#二叉树的遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的遍历&quot;&gt;&lt;/a&gt;二叉树的遍历&lt;/h2&gt;&lt;p&gt;二叉树的遍历，指的是按照一定的规则和顺序走遍二叉树的所有结点，使得每个节点都被访问一次，而且只被访问一次。&lt;br&gt;基本的遍历方法有先序、中序和后序遍历算法，并且都有递归和非递归之分。这三种方法的递归算法实现如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//先序遍历&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PreOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(T!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	Visit(T);    //Visit(T)为访问当前节点的操作，如输出该节点的值等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	PreOrder(T-&amp;gt;lchild); //访问左子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	PreOrder(T-&amp;gt;rchild); //访问右子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//中序遍历&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void InOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if(T!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		InOrder(T-&amp;gt;lchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Visit(T);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		InOrder(T-&amp;gt;rchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//后序遍历&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PostOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if(T!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		PostOrder(T-&amp;gt;lchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		PostOrder(T-&amp;gt;rchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Visit(T);		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对应地，给出以上算法的非递归算法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 先序遍历： &lt;/strong&gt;&lt;br&gt;访问T-&amp;gt;data后，将T入栈，遍历左子树；遍历完左子树返回时，栈顶元素为T,出栈，再先序遍历T的右子树&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void PreOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stack&amp;lt;BiTree&amp;gt; stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//定义一个指针，用来遍历二叉树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BiTree p=T;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//栈不为空或者p不为空时循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(p||!stack.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(p!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			//当前节点入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stack.push(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Visit(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			//遍历左子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p=p-&amp;gt;lchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p=stack.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stack.pop();  //出栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p=p-&amp;gt;rchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 中序遍历 &lt;/strong&gt;&lt;br&gt;先将T（根节点）入栈，遍历左子树；遍历完左子树返回时，出栈，访问T-&amp;gt;data,出栈，再先序遍历T的右子树&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void InOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stack&amp;lt;BiTree&amp;gt; stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//定义一个遍历二叉树的指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BiTree p=T;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//栈不为空或者p不为空时循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(p|| !stack.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(p!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stack.push(p); //入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p=p-&amp;gt;lchild;   //遍历左子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			//出栈，访问根节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p=stack.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Visit(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			//访问右子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p=p-&amp;gt;rchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 后序遍历 &lt;/strong&gt;&lt;br&gt;T为要遍历树的根指针，后序遍历要求先遍历完左右子树，再访问根结点。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//后序遍历(非递归)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct BiTNodePost&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BiTree biTree;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char tag;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;BiTNodePost,*BiTreePost;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void PostOrder2(BiTree T)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack&amp;lt;BiTreePost&amp;gt; stack;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //p是遍历指针  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BiTree p = T;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BiTreePost BT;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //栈不空或者p不空时循环  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(p != NULL || !stack.empty())&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //遍历左子树  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(p != NULL)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT = (BiTreePost)malloc(sizeof(BiTNodePost));  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT-&amp;gt;biTree = p;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //访问过左子树  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT-&amp;gt;tag = &amp;apos;L&amp;apos;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.push(BT);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p-&amp;gt;lchild;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //左右子树访问完毕访问根节点  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(!stack.empty() &amp;amp;&amp;amp; (stack.top())-&amp;gt;tag == &amp;apos;R&amp;apos;)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT = stack.top();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //退栈  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stack.pop();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT-&amp;gt;biTree;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;%c &amp;quot;,BT-&amp;gt;biTree-&amp;gt;data);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //遍历右子树  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(!stack.empty())&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT = stack.top();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //访问过右子树  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            BT-&amp;gt;tag = &amp;apos;R&amp;apos;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = BT-&amp;gt;biTree;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p-&amp;gt;rchild;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 广度优先（层次遍历）算法和深度优先遍历 &lt;/strong&gt;&lt;br&gt;除了上述几种遍历算法之外(从本质上讲，先序、中序、后序遍历都属于深度优先遍历)，还有广度优先算法和深度优先遍历，这里给出这两个算法的实现&lt;br&gt;&lt;strong&gt; 广度优先 &lt;/strong&gt;&lt;br&gt;思路：从顶向下，从左至右的顺序来逐层访问每个结点，这里需要用到的存储结构为&lt;strong&gt; 队列 &lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void LevelOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BiTree p=T;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	queue&amp;lt;BiTree&amp;gt; queue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//根结点入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	queue.push(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	//队列不为空时循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(!queue.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//对头元素出列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p=queue.front();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//访问p指向的结点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Visit(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		queue.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(p-&amp;gt;lchild!=NULL)&amp;#123; //左子树不为空，将左子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			queue.push(p-&amp;gt;lchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(p-&amp;gt;rchild!=NULL)&amp;#123;  //右子树不为空，将右子树入队&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			queue.push(p-&amp;gt;rchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 深度优先 &lt;/strong&gt;&lt;br&gt;思路：先遍历根结点，接着遍历左子树，最后遍历右子树，这里借助&lt;strong&gt; 栈 &lt;/strong&gt; 来实现深度优先遍历&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void DepthOrder(BiTree T)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stack&amp;lt;BiTree&amp;gt; stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	BiTree p=T;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stack.push(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(!stack.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p=stack.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Visit(p);   //遍历根结点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack.pop(); //出栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(p-&amp;gt;rchild)&amp;#123; //右子树入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stack.push(p-&amp;gt;rchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(p-&amp;gt;lchild)&amp;#123;  //左子树入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			stack.push(p-&amp;gt;lchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树的子树有左右之分，次序不能颠倒。这里对二叉树的几种遍历算法做一下整理，供大家学习。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python与机器学习 贝叶斯算法</title>
    <link href="http://WustChuiChui.github.io/2016/04/12/bayes/"/>
    <id>http://WustChuiChui.github.io/2016/04/12/bayes/</id>
    <published>2016-04-12T10:05:02.000Z</published>
    <updated>2016-04-12T12:52:55.270Z</updated>
    
    <content type="html">&lt;p&gt;朴素贝叶斯分类时一种十分简单的分类算法，称其朴素是因为其思想基础的简单性，对文本分类而言，它认为词袋中的两两词之间的关系是相互独立的，即一个对象的特征向量中每个维度都是相互独立的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Python与机器学习-贝叶斯算法&quot;&gt;&lt;a href=&quot;#Python与机器学习-贝叶斯算法&quot; class=&quot;headerlink&quot; title=&quot;Python与机器学习 贝叶斯算法&quot;&gt;&lt;/a&gt;Python与机器学习 贝叶斯算法&lt;/h1&gt;&lt;h2 id=&quot;一、定义&quot;&gt;&lt;a href=&quot;#一、定义&quot; class=&quot;headerlink&quot; title=&quot;一、定义&quot;&gt;&lt;/a&gt;一、定义&lt;/h2&gt;&lt;p&gt;(1)设x={a1,a2,…,am}为一个待分类项，而每个a为x的一个特征属性;&lt;br&gt;(2)有类别集合C={y1,y2,…,yn};&lt;br&gt;(3)计算P(y1|x),P(y2|x),…,P(yn|x);&lt;br&gt;(4)如果P(yk|x)=max{P(y1|x),P(y2|x),…,P(yn|x)},则x属于yk。&lt;/p&gt;
&lt;p&gt;上述定义给出了对x样本进行分类的准则，分类的关键是计算各个条件概率。可以按以下步骤计算。&lt;br&gt;(1)找到一个已知分类的待分类项集合，也就是训练集；&lt;br&gt;(2)统计得到在各类别下各个特征属性的条件概率估计；&lt;br&gt;(3)如果各个特征属性是条件独立的(或者假设它们是相互独立的)，则根据贝叶斯定义有如下推论：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006qSkuxgw1f2u3ez8ww3j30qk02mq3g.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、分类流程&quot;&gt;&lt;a href=&quot;#二、分类流程&quot; class=&quot;headerlink&quot; title=&quot;二、分类流程&quot;&gt;&lt;/a&gt;二、分类流程&lt;/h2&gt;&lt;p&gt;(1)训练数据生成训练样本集：TF-IDF&lt;br&gt;(2)对每个类别计算P(yi)&lt;br&gt;(3)对每个特征属性计算所有划分的条件概率&lt;br&gt;(4)对每个类别计算P(x|yi)P(yi)&lt;br&gt;(5)以(x|yi)P(yi)的最大项判断x的所属类别&lt;/p&gt;
&lt;h2 id=&quot;三、算法实现&quot;&gt;&lt;a href=&quot;#三、算法实现&quot; class=&quot;headerlink&quot; title=&quot;三、算法实现&quot;&gt;&lt;/a&gt;三、算法实现&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def loadDataSet():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    postingList=[[&amp;apos;my&amp;apos;,&amp;apos;dog&amp;apos;,&amp;apos;has&amp;apos;,&amp;apos;flea&amp;apos;,&amp;apos;poblems&amp;apos;,&amp;apos;help&amp;apos;,&amp;apos;please&amp;apos;],[&amp;apos;maybe&amp;apos;,&amp;apos;not&amp;apos;,&amp;apos;take&amp;apos;,&amp;apos;him&amp;apos;,&amp;apos;to&amp;apos;,&amp;apos;dog&amp;apos;,&amp;apos;park&amp;apos;,&amp;apos;stupid&amp;apos;],[&amp;apos;my&amp;apos;,&amp;apos;dalmation&amp;apos;,&amp;apos;is&amp;apos;,&amp;apos;so&amp;apos;,&amp;apos;cute&amp;apos;,&amp;apos;I&amp;apos;,&amp;apos;love&amp;apos;,&amp;apos;him&amp;apos;,&amp;apos;my&amp;apos;],[&amp;apos;stop&amp;apos;,&amp;apos;posting&amp;apos;,&amp;apos;stupid&amp;apos;,&amp;apos;worthless&amp;apos;,&amp;apos;garbage&amp;apos;],[&amp;apos;mr&amp;apos;,&amp;apos;licks&amp;apos;,&amp;apos;ate&amp;apos;,&amp;apos;my&amp;apos;,&amp;apos;steak&amp;apos;,&amp;apos;how&amp;apos;,&amp;apos;to&amp;apos;,&amp;apos;stop&amp;apos;,&amp;apos;to&amp;apos;,&amp;apos;stop&amp;apos;,&amp;apos;him&amp;apos;],[&amp;apos;quit&amp;apos;,&amp;apos;buying&amp;apos;,&amp;apos;worthles&amp;apos;,&amp;apos;dog&amp;apos;,&amp;apos;food&amp;apos;,&amp;apos;stupid&amp;apos;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    classVec=[0,1,0,1,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return postingList,classVec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #这里postingList,classVec分别为训练集和对应的分类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #编写一个bayes算法类，实现该算法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #默认构造方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class NBayes(object):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def __init__(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.vocabulary=[]             #词典&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.idf=0                     #词典的IDF权值向量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tf=0                      #训练集中的权值矩阵&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tdm=0                     #P(x|yi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.Pcates=&amp;#123;&amp;#125;                 #P(yi)是一个类别字典&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.lables=[]                 #对应每个文本的分类，是一个外部导入的列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.doclength=0               #训练集文本数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.vocablen=0                #词典词长&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.testset=0                 #测试集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #导入和训练集数据，生成算法必需的参数和数据结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def train_set(self,trainset,classVec):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.cate_prob(classVec)      #计算每个分类在数据集中的概率P(yi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.doclength=len(trainset)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tempset=set()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [tempset.add(word) for doc i trainset for word in doc] #生成词典&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.vocabulary=list(tempset)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.vocablen=len(self.vocabulary)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.calc_wordfreq(trainset)    #计算词频数据集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.built_tdm()                #按分类累计向量空间的每维值P(x|yi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #cate_prob函数,计算在数据集中每个分类的概率P(yi)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def cate_prob(self,classVec):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.lables=classVec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        labletemps=set(self.lables) #全部分类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for labletemp in labletemps:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.lables.count(labletemp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.Pcates[labletemp]=float(self.lables.count(labletemp))/float(len(self.lables))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #calc_wordfreq函数，生成普通的词频向量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def calc_wordfreq(self,trainset):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.idf=np.zeros([1,self.vocablen])   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tf=np.zeros(self.doclength,self.vocablen)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for indx in xrange(self.doclength):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for word in trainset[indx]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.tf[indx,self.vocabulary.index(word)]+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for signleword in set(trainset[indx]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                self.idf[0,self.vocabulary.index(signleword)]+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #built_tdm函数，按分类累计计算向量空间的每维值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def built_tdm(self):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tdm=np.zeros([len(self.Pcates),self.vocablen])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sumlist=np.zeros([len(self.Pcates),1])    #统计每个分类的总值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for indx in xrange(self.doclength):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #将同一类别的词向量空间值相加&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.tdm[self.lables[indx]]+=self.tf[indx]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            #统计每个分类的总值，它为一个标量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sumlist[self.lables[indx]]=np.sum(self.tdm[self.lables[indx]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.tdm=self.tdm/sumlist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #map2vocab函数，将测试集映射到当前词典&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def map2vovocab(self,testdata):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.testdata=np.zeros([1,self.vocablen])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for word in testdata:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.testdata[0,self.vocabulary.index(word)]+=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    #predict函数，预测分类结果，输出预测的分类类别&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def predict(self,testdata):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if np.shape(testdata)[1]!=self.vocablen:     #测试集长度与词典长度不相等，则退出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print &amp;quot;Error input&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            exit(0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        predvalue=0  #初始化类别概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        predclass=&amp;quot;&amp;quot; #初始化类别名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for tdm_vect,keyclass in zip(self.tdm,self.Pcates):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp=np.sum(testset*tdm_vect*self.Pcates[keyclass])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if temp&amp;gt;predvalue:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                predvalue=temp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                predclass=keyclass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return predclass&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;朴素贝叶斯分类时一种十分简单的分类算法，称其朴素是因为其思想基础的简单性，对文本分类而言，它认为词袋中的两两词之间的关系是相互独立的，即一个对象的特征向量中每个维度都是相互独立的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <link href="http://WustChuiChui.github.io/2016/04/12/ReorderArray/"/>
    <id>http://WustChuiChui.github.io/2016/04/12/ReorderArray/</id>
    <published>2016-04-12T07:53:05.000Z</published>
    <updated>2016-04-12T09:33:39.663Z</updated>
    
    <content type="html">&lt;p&gt;问题描述：输入一个整数数组，实现一个函数调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;调整数组顺序使奇数位于偶数前面&quot;&gt;&lt;a href=&quot;#调整数组顺序使奇数位于偶数前面&quot; class=&quot;headerlink&quot; title=&quot;调整数组顺序使奇数位于偶数前面&quot;&gt;&lt;/a&gt;调整数组顺序使奇数位于偶数前面&lt;/h1&gt;&lt;p&gt;一种基础的思路：先不考虑时间复杂度，从开开始遍历数组，当当前位置为偶数时，将位于该元素后面的数字整体向前移动一位，同时将该节点的数字放在数组的最后位置，每遇到一个偶数需要移动O(n)个数字，时间复杂度为O(n2).&lt;/p&gt;
&lt;p&gt;现给出另一种思路，在扫描的过程中，如果发现有偶数在奇数的前面，则交换他们的位置，交换之后就符合要求了。基于上述分析，给出如下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void ReorderOddEven(int *pData,int length)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(pData==NULL ||length==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int *pBegin=pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int *pEnd=pData+length-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(pBegin&amp;lt;pEnd)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; (*pBegin &amp;amp; ox1)!=0)&amp;#123;  //找到第一个偶数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 pBegin++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; (*pEnd &amp;amp; ox1)==0)&amp;#123;     //找到第一个奇数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            eEnd--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     if(pBegin&amp;lt;pEnd)&amp;#123;       //交换奇数和偶数的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int temp=*pBegin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *pBegin=*pEnd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *pEnd=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在如果要对上述算法进行扩展，比如：将题目简单的修改一下，将数组按大小分成两部分？将负数放在前面，正数放在后面？为了将代码进一步抽象，可以给出一个模式，修改函数ReorderOddEven中的判断标准，其他的逻辑框架不需要改动。有以下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void ReorderOddEven(int *pData,int length,bool (*func)(int))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(pData==NULL ||length==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int *pBegin=pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int *pEnd=pData+length-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(pBegin&amp;lt;pEnd)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; !func(*pBegin))&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 pBegin++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(pBegin&amp;lt;pEnd &amp;amp;&amp;amp; func(*pEnd))&amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            eEnd--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     if(pBegin&amp;lt;pEnd)&amp;#123;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int temp=*pBegin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *pBegin=*pEnd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *pEnd=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool isEven(int n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (n &amp;amp; 1)==0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外对给出的第一个算法，这里在实现题目要求时，奇偶数的相对顺序发生了变化，如果要使得在重排后奇偶数的相对顺序不变。可以借用栈或队列等容器来实现，当然，这意味着额外的内存开销，最差的情况为O(n),其代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void reOrderOddEven(vector&amp;lt;int&amp;gt; &amp;amp;array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if(array.size()&amp;lt;=0)            //异常处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      vector&amp;lt;int&amp;gt; odds,evens;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      unsigned int i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      for(i=0;i&amp;lt;array.size();i++)&amp;#123;   //分别将奇数和偶数存入一个vector容器中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          if((array[i]&amp;amp;0x1)!=0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             odds.push_back(array[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          if((array[i]&amp;amp;0x1)==0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             evens.push_back(array[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      for(i=0;i&amp;lt;odds.size();i++)   //将奇数和偶数分别存入array中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          array[i]=odds[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      int k=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      for(i=0;i&amp;lt;evens.size();i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          array[k++]=evens[i];        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;问题描述：输入一个整数数组，实现一个函数调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>几种从尾到头输出链表的算法比较</title>
    <link href="http://WustChuiChui.github.io/2016/04/12/Resert-print-list/"/>
    <id>http://WustChuiChui.github.io/2016/04/12/Resert-print-list/</id>
    <published>2016-04-12T01:52:50.000Z</published>
    <updated>2016-04-12T02:28:00.463Z</updated>
    
    <content type="html">&lt;p&gt;链表是一个是一种动态的线性结构，在创建链表时，无需知道链表的长度，每插入一个结点时，动态地为其分配内存，在输出链表时（单向链表），一般可沿着头指针逐步遍历所有节点，然而，要从尾到头遍历链表，可有以下几种思路：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;几种从尾到头输出链表的算法比较&quot;&gt;&lt;a href=&quot;#几种从尾到头输出链表的算法比较&quot; class=&quot;headerlink&quot; title=&quot;几种从尾到头输出链表的算法比较&quot;&gt;&lt;/a&gt;几种从尾到头输出链表的算法比较&lt;/h1&gt;&lt;h2 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h2&gt;&lt;p&gt;在不破坏链表结构的前提下，对链表进行逆序输出，首先想到的应该是栈这样的一个结构，下面给出一个用栈实现的输出算法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//链表数据结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct ListNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        struct ListNode *next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode(int x) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             val(x), next(NULL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//利用栈结构对链表进行从尾到头输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void printListFromTailToHead(ListNode* head)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack&amp;lt;ListNode&amp;gt; nodes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode* pNode=head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(pNode!=NULL)&amp;#123;  //依次入栈&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nodes.push(pNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pNode=pNode-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //出栈输出结构即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(!nodes.empty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pNode=nodes.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt; pNode-&amp;gt;val &amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nodes.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于递归在本质上就是一个栈结构，既然可以利用栈实现该算法，则利用递归也可以实现，本算法的递归算法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void printListFromTailToHead(ListNode* head)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(head !=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(head-&amp;gt;next!=NULL)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           printListFromTailToHead(head-&amp;gt;next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cout&amp;lt;&amp;lt; head-&amp;gt;val &amp;lt;&amp;lt; endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上两种算法都可实现题目要求，但有时我们希望将输出作为一个函数返回值，方便以后对其进行调用，可对以上算法稍做修改即可：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;int&amp;gt; printListFromTailToHead(struct ListNode* head) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack&amp;lt;int&amp;gt; vestack;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;int&amp;gt; ret;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (head != NULL)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vestack.push(head-&amp;gt;val);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head = head-&amp;gt;next;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (!vestack.empty())&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int val = vestack.top();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret.push_back(val);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vestack.pop();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ret;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;递归算法实现&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;int&amp;gt; printListFromTailToHead(struct ListNode* head)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;int&amp;gt; ret;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (NULL != head)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (NULL != head-&amp;gt;next)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printListFromTailToHead(head-&amp;gt;next);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret.push_back(head-&amp;gt;val);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ret;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在可以有效从头到尾输出链表，并将结果存在一个vector结构中，但这里仍然存在一个严重的问题：&lt;br&gt;&lt;strong&gt; 在利用递归实现该算法时，当链表的长度较长时，会出现栈溢出的问题，而递归本质上也是一种栈结构，所有上述四种方法可能都存在这样的隐患。 &lt;/strong&gt; 考虑到上述问题，既然利用vector对其进行存储，不妨在顺序遍历链表时依次将当前节点的val值插入到vector中。其实现代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;int&amp;gt; printListFromTailToHead(struct ListNode* head) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vector&amp;lt;int&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode* p=head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.insert(result.begin(),p-&amp;gt;val);  //依次插入当前节点的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p=p-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;链表是一个是一种动态的线性结构，在创建链表时，无需知道链表的长度，每插入一个结点时，动态地为其分配内存，在输出链表时（单向链表），一般可沿着头指针逐步遍历所有节点，然而，要从尾到头遍历链表，可有以下几种思路：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>那些年，我们一起写过的快排</title>
    <link href="http://WustChuiChui.github.io/2016/04/10/quick-sort/"/>
    <id>http://WustChuiChui.github.io/2016/04/10/quick-sort/</id>
    <published>2016-04-10T14:14:25.000Z</published>
    <updated>2016-04-10T14:48:23.475Z</updated>
    
    <content type="html">&lt;p&gt;在几种常用的排序算法中，快速排序总体的平均效率是最优的，这里对快速排序给出C++版的代码，希望大家相互学习。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;那些年，我们一起写过的快排&quot;&gt;&lt;a href=&quot;#那些年，我们一起写过的快排&quot; class=&quot;headerlink&quot; title=&quot;那些年，我们一起写过的快排&quot;&gt;&lt;/a&gt;那些年，我们一起写过的快排&lt;/h1&gt;&lt;h2 id=&quot;一、基本思路&quot;&gt;&lt;a href=&quot;#一、基本思路&quot; class=&quot;headerlink&quot; title=&quot;一、基本思路&quot;&gt;&lt;/a&gt;一、基本思路&lt;/h2&gt;&lt;p&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;br&gt;快速排序是一种&lt;strong&gt; 不稳定 &lt;/strong&gt;的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。&lt;/p&gt;
&lt;h2 id=&quot;二、算法分析&quot;&gt;&lt;a href=&quot;#二、算法分析&quot; class=&quot;headerlink&quot; title=&quot;二、算法分析&quot;&gt;&lt;/a&gt;二、算法分析&lt;/h2&gt;&lt;p&gt;实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两个部分，其中，比关键字小的数字移到数组的左边，比关键字大的数字移到数组的右边。&lt;/p&gt;
&lt;h2 id=&quot;三、相关代码实现&quot;&gt;&lt;a href=&quot;#三、相关代码实现&quot; class=&quot;headerlink&quot; title=&quot;三、相关代码实现&quot;&gt;&lt;/a&gt;三、相关代码实现&lt;/h2&gt;&lt;p&gt;先看数据结构中给出的基本算法代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void QuickSort(int s[], int l, int r)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (l&amp;lt; r)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int i = l, j = r, x = s[l];      //以第一个数为参考基准&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while (i &amp;lt; j)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(i &amp;lt; j &amp;amp;&amp;amp; s[j]&amp;gt;= x) // 从右向左找第一个小于x的数  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j--;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(i &amp;lt; j)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                s[i++] = s[j];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(i &amp;lt; j &amp;amp;&amp;amp; s[i]&amp;lt; x) // 从左向右找第一个大于等于x的数  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i++;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(i &amp;lt; j)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                s[j--] = s[i];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s[i] = x;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        QuickSort(s, l, i - 1); // 递归调用  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        QuickSort(s, i + 1, r);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里给出另一个版本的快速排序算法:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int Partition(int data[],int length,int start,int end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //定义的一个函数，在数组DATA中选择一个数字，将数组中小于关键字的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //部分全放在关键字的左侧，大于关键字的部分放在右侧，返回关键字的索引&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //参数异常处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(data==NULL || length&amp;lt;0 || start&amp;lt;0 || end&amp;gt;=length)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throw new std:exception(&amp;quot;参数输入非法!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int index=RandomInrange(start,end);   //在start 和end 直接随机取一个值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //data[index]作为关键字，先将其放在最后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Swap(&amp;amp;data[index],&amp;amp;data[end]);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int small=start-1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for(index=start;index&amp;lt;end;++index)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     if(data[index]&amp;lt;data[end])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ++small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(small!=index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Swap(&amp;amp;data[index],&amp;amp;data[small]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ++small;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Swap(&amp;amp;data[small],&amp;amp;data[end]);   //最终small的位置即对应为关键字的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return small; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void QuickSort(int data[],int length,int start,int end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(start==end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     return ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     //将数组分成两个部分，index前面的数字都比data[index]小，后面的数字都大于或等于data[index]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      int index=Partition(data,length,start,end); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if(index&amp;gt;start)      //递归&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      QuickSort(data,length,start,index-1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if(index&amp;lt;end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      QuickSort(data,length,index+1,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、两种算法的比较&quot;&gt;&lt;a href=&quot;#四、两种算法的比较&quot; class=&quot;headerlink&quot; title=&quot;四、两种算法的比较&quot;&gt;&lt;/a&gt;四、两种算法的比较&lt;/h2&gt;&lt;p&gt;1、这里给出的代码在选取参考数字时，使用的随机选取知道方法，而前者是直接使用第一数字作为参考；&lt;br&gt;2、后面的代码在输入参数出现异常时能正确给出响应提示，因而更加鲁棒。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在几种常用的排序算法中，快速排序总体的平均效率是最优的，这里对快速排序给出C++版的代码，希望大家相互学习。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python与机器学习基础 之数据可视化</title>
    <link href="http://WustChuiChui.github.io/2016/04/09/data-visualization/"/>
    <id>http://WustChuiChui.github.io/2016/04/09/data-visualization/</id>
    <published>2016-04-09T14:30:43.000Z</published>
    <updated>2016-04-10T05:10:53.477Z</updated>
    
    <content type="html">&lt;p&gt;机器学习中常常会用到大量的数据表，对数据进行可视化有助于对数据进行分析，这里主要介绍几种常用的数据可视化方向，包括表等线性结构、图等网络结构的可视化方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Python与机器学习基础-之数据可视化&quot;&gt;&lt;a href=&quot;#Python与机器学习基础-之数据可视化&quot; class=&quot;headerlink&quot; title=&quot;Python与机器学习基础 之数据可视化&quot;&gt;&lt;/a&gt;Python与机器学习基础 之数据可视化&lt;/h1&gt;&lt;h2 id=&quot;一、表与线性结构的可视化&quot;&gt;&lt;a href=&quot;#一、表与线性结构的可视化&quot; class=&quot;headerlink&quot; title=&quot;一、表与线性结构的可视化&quot;&gt;&lt;/a&gt;一、表与线性结构的可视化&lt;/h2&gt;&lt;p&gt;Python提供了4种容器结构——list、dict、set、tuple来装载数据，其中线性结构包括两种：list和tuple。因为tuple是只读结构，用于最常用的外部生成器生成的数据，所以&lt;strong&gt; 最常用的线性结构是list &lt;/strong&gt;。NumPy的矩阵结构可在Matplotlib中实现可视化。例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import numpy as np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#曲线数据加入噪声&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X=np.linspace(-5,5,200)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Y=np.sin(X)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yn=Y+np.random.rand(1,len(Y))*1.5    #噪声&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#绘图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fig=plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax=fig.add_subplot(111)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.scatter(X,yn,c=&amp;apos;blue&amp;apos;,marker=&amp;apos;o&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.plot(X,Y+0.75,&amp;apos;r&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其输出结果为：&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/006qSkuxjw1f2qtxgvvhcj30ay07ct9h.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、图等网络结构的可视化&quot;&gt;&lt;a href=&quot;#二、图等网络结构的可视化&quot; class=&quot;headerlink&quot; title=&quot;二、图等网络结构的可视化&quot;&gt;&lt;/a&gt;二、图等网络结构的可视化&lt;/h2&gt;&lt;p&gt;图和网络结构是神经网络中重要的数据结构，一般用dict和list进行存储，使用NumPy中的矩阵结构存储点坐标；弧的坐标使用距离计算公式。例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;from numpy import *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import treePlotter as tp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#配置UTF-8输出环境&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#reload(sys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#sys.setdefaultencoding(&amp;apos;utf-8&amp;apos;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dist=mat([[0.1,0.1],[0.9,0.5],[0.9,0.1],[0.45,0.9],[0.9,0.8],[0.7,0.9],[0.1,0.45],[0.45,0.1]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;m,n=shape(dist)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fig=plt.figure()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax=fig.add_subplot(111)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.scatter(dist.T[0],dist.T[1],c=&amp;apos;blue&amp;apos;,marker=&amp;apos;o&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for point in dist.tolist():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    plt.annotate(&amp;quot;(&amp;quot;+str(point[0])+&amp;quot;,&amp;quot;+str(point[1])+&amp;quot;)&amp;quot;,xy=(point[0],point[1]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xlist=[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ylist=[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for px,py in zip(dist.T.tolist()[0],dist.T.tolist()[1]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xlist=append(px)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ylist=append(py)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax.plot(xlist,ylist,&amp;apos;r&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、树等分支结构的可视化&quot;&gt;&lt;a href=&quot;#三、树等分支结构的可视化&quot; class=&quot;headerlink&quot; title=&quot;三、树等分支结构的可视化&quot;&gt;&lt;/a&gt;三、树等分支结构的可视化&lt;/h2&gt;&lt;p&gt;树是一种非线性的结构，一般用来分类树算法，Python使用dict字典型数据实现存储。Matplotlib没有提供专门绘制树的API.Peter Harrington提供了一个简单绘制树的模块。例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import numpy as np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import treePlotter as tp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reload(sys)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sys.setdefaultencoding(&amp;apos;utf-8&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myTree=&amp;#123;&amp;apos;root&amp;apos;:&amp;#123;0:&amp;apos;leaf node&amp;apos;,1:&amp;#123;&amp;apos;level 2&amp;apos;:&amp;#123;0:&amp;apos;leaf node&amp;apos;,1:&amp;apos;leaf node&amp;apos;&amp;#125;&amp;#125;,2:&amp;#123;&amp;apos;level 2&amp;apos;:&amp;#123;0:&amp;apos;leaf node&amp;apos;,1:&amp;apos;leaf node&amp;apos;&amp;#125;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tp.createPlot(myTree)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习中常常会用到大量的数据表，对数据进行可视化有助于对数据进行分析，这里主要介绍几种常用的数据可视化方向，包括表等线性结构、图等网络结构的可视化方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
